// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SensorService.proto

#ifndef PROTOBUF_SensorService_2eproto__INCLUDED
#define PROTOBUF_SensorService_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace SensorService {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_SensorService_2eproto();
void protobuf_AssignDesc_SensorService_2eproto();
void protobuf_ShutdownFile_SensorService_2eproto();

class RegisterListener;
class Request;
class Response;
class Sensor;
class SensorAccuracyEvent;
class SensorDataEvent;
class UnregisterListener;

enum RegisterListener_RegisterType {
  RegisterListener_RegisterType_STREAM = 0,
  RegisterListener_RegisterType_TRIGGER = 1
};
bool RegisterListener_RegisterType_IsValid(int value);
const RegisterListener_RegisterType RegisterListener_RegisterType_RegisterType_MIN = RegisterListener_RegisterType_STREAM;
const RegisterListener_RegisterType RegisterListener_RegisterType_RegisterType_MAX = RegisterListener_RegisterType_TRIGGER;
const int RegisterListener_RegisterType_RegisterType_ARRAYSIZE = RegisterListener_RegisterType_RegisterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegisterListener_RegisterType_descriptor();
inline const ::std::string& RegisterListener_RegisterType_Name(RegisterListener_RegisterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegisterListener_RegisterType_descriptor(), value);
}
inline bool RegisterListener_RegisterType_Parse(
    const ::std::string& name, RegisterListener_RegisterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegisterListener_RegisterType>(
    RegisterListener_RegisterType_descriptor(), name, value);
}
enum Request_RequestType {
  Request_RequestType_REGISTER = 0,
  Request_RequestType_UNREGISTER = 1,
  Request_RequestType_GET_SENSOR_LIST = 2
};
bool Request_RequestType_IsValid(int value);
const Request_RequestType Request_RequestType_RequestType_MIN = Request_RequestType_REGISTER;
const Request_RequestType Request_RequestType_RequestType_MAX = Request_RequestType_GET_SENSOR_LIST;
const int Request_RequestType_RequestType_ARRAYSIZE = Request_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_RequestType_descriptor();
inline const ::std::string& Request_RequestType_Name(Request_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_RequestType_descriptor(), value);
}
inline bool Request_RequestType_Parse(
    const ::std::string& name, Request_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_RequestType>(
    Request_RequestType_descriptor(), name, value);
}
enum Response_ResponseType {
  Response_ResponseType_SENSOR_LIST = 0,
  Response_ResponseType_SENSOR_DATA = 1,
  Response_ResponseType_SENSOR_ACCURACY = 2
};
bool Response_ResponseType_IsValid(int value);
const Response_ResponseType Response_ResponseType_ResponseType_MIN = Response_ResponseType_SENSOR_LIST;
const Response_ResponseType Response_ResponseType_ResponseType_MAX = Response_ResponseType_SENSOR_ACCURACY;
const int Response_ResponseType_ResponseType_ARRAYSIZE = Response_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor();
inline const ::std::string& Response_ResponseType_Name(Response_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ResponseType_descriptor(), value);
}
inline bool Response_ResponseType_Parse(
    const ::std::string& name, Response_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ResponseType>(
    Response_ResponseType_descriptor(), name, value);
}
// ===================================================================

class RegisterListener : public ::google::protobuf::Message {
 public:
  RegisterListener();
  virtual ~RegisterListener();

  RegisterListener(const RegisterListener& from);

  inline RegisterListener& operator=(const RegisterListener& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterListener& default_instance();

  void Swap(RegisterListener* other);

  // implements Message ----------------------------------------------

  inline RegisterListener* New() const { return New(NULL); }

  RegisterListener* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterListener& from);
  void MergeFrom(const RegisterListener& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterListener* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RegisterListener_RegisterType RegisterType;
  static const RegisterType STREAM = RegisterListener_RegisterType_STREAM;
  static const RegisterType TRIGGER = RegisterListener_RegisterType_TRIGGER;
  static inline bool RegisterType_IsValid(int value) {
    return RegisterListener_RegisterType_IsValid(value);
  }
  static const RegisterType RegisterType_MIN =
    RegisterListener_RegisterType_RegisterType_MIN;
  static const RegisterType RegisterType_MAX =
    RegisterListener_RegisterType_RegisterType_MAX;
  static const int RegisterType_ARRAYSIZE =
    RegisterListener_RegisterType_RegisterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RegisterType_descriptor() {
    return RegisterListener_RegisterType_descriptor();
  }
  static inline const ::std::string& RegisterType_Name(RegisterType value) {
    return RegisterListener_RegisterType_Name(value);
  }
  static inline bool RegisterType_Parse(const ::std::string& name,
      RegisterType* value) {
    return RegisterListener_RegisterType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SensorService.RegisterListener.RegisterType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::SensorService::RegisterListener_RegisterType type() const;
  void set_type(::SensorService::RegisterListener_RegisterType value);

  // required int32 sensorHandle = 2;
  bool has_sensorhandle() const;
  void clear_sensorhandle();
  static const int kSensorHandleFieldNumber = 2;
  ::google::protobuf::int32 sensorhandle() const;
  void set_sensorhandle(::google::protobuf::int32 value);

  // optional int32 samplingPeriodUs = 3;
  bool has_samplingperiodus() const;
  void clear_samplingperiodus();
  static const int kSamplingPeriodUsFieldNumber = 3;
  ::google::protobuf::int32 samplingperiodus() const;
  void set_samplingperiodus(::google::protobuf::int32 value);

  // optional int32 maxReportLatencyUs = 4;
  bool has_maxreportlatencyus() const;
  void clear_maxreportlatencyus();
  static const int kMaxReportLatencyUsFieldNumber = 4;
  ::google::protobuf::int32 maxreportlatencyus() const;
  void set_maxreportlatencyus(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SensorService.RegisterListener)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sensorhandle();
  inline void clear_has_sensorhandle();
  inline void set_has_samplingperiodus();
  inline void clear_has_samplingperiodus();
  inline void set_has_maxreportlatencyus();
  inline void clear_has_maxreportlatencyus();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::int32 sensorhandle_;
  ::google::protobuf::int32 samplingperiodus_;
  ::google::protobuf::int32 maxreportlatencyus_;
  friend void  protobuf_AddDesc_SensorService_2eproto();
  friend void protobuf_AssignDesc_SensorService_2eproto();
  friend void protobuf_ShutdownFile_SensorService_2eproto();

  void InitAsDefaultInstance();
  static RegisterListener* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterListener : public ::google::protobuf::Message {
 public:
  UnregisterListener();
  virtual ~UnregisterListener();

  UnregisterListener(const UnregisterListener& from);

  inline UnregisterListener& operator=(const UnregisterListener& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnregisterListener& default_instance();

  void Swap(UnregisterListener* other);

  // implements Message ----------------------------------------------

  inline UnregisterListener* New() const { return New(NULL); }

  UnregisterListener* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnregisterListener& from);
  void MergeFrom(const UnregisterListener& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterListener* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 sensorHandle = 1;
  bool has_sensorhandle() const;
  void clear_sensorhandle();
  static const int kSensorHandleFieldNumber = 1;
  ::google::protobuf::int32 sensorhandle() const;
  void set_sensorhandle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SensorService.UnregisterListener)
 private:
  inline void set_has_sensorhandle();
  inline void clear_has_sensorhandle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 sensorhandle_;
  friend void  protobuf_AddDesc_SensorService_2eproto();
  friend void protobuf_AssignDesc_SensorService_2eproto();
  friend void protobuf_ShutdownFile_SensorService_2eproto();

  void InitAsDefaultInstance();
  static UnregisterListener* default_instance_;
};
// -------------------------------------------------------------------

class Sensor : public ::google::protobuf::Message {
 public:
  Sensor();
  virtual ~Sensor();

  Sensor(const Sensor& from);

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sensor& default_instance();

  void Swap(Sensor* other);

  // implements Message ----------------------------------------------

  inline Sensor* New() const { return New(NULL); }

  Sensor* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sensor& from);
  void MergeFrom(const Sensor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string vendor = 2;
  bool has_vendor() const;
  void clear_vendor();
  static const int kVendorFieldNumber = 2;
  const ::std::string& vendor() const;
  void set_vendor(const ::std::string& value);
  void set_vendor(const char* value);
  void set_vendor(const char* value, size_t size);
  ::std::string* mutable_vendor();
  ::std::string* release_vendor();
  void set_allocated_vendor(::std::string* vendor);

  // required int32 version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // required int32 handle = 4;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 4;
  ::google::protobuf::int32 handle() const;
  void set_handle(::google::protobuf::int32 value);

  // required int32 type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // required float maxRange = 6;
  bool has_maxrange() const;
  void clear_maxrange();
  static const int kMaxRangeFieldNumber = 6;
  float maxrange() const;
  void set_maxrange(float value);

  // required float resolution = 7;
  bool has_resolution() const;
  void clear_resolution();
  static const int kResolutionFieldNumber = 7;
  float resolution() const;
  void set_resolution(float value);

  // required float power = 8;
  bool has_power() const;
  void clear_power();
  static const int kPowerFieldNumber = 8;
  float power() const;
  void set_power(float value);

  // required int32 minDelay = 9;
  bool has_mindelay() const;
  void clear_mindelay();
  static const int kMinDelayFieldNumber = 9;
  ::google::protobuf::int32 mindelay() const;
  void set_mindelay(::google::protobuf::int32 value);

  // required uint32 fifoReservedEventCount = 10;
  bool has_fiforeservedeventcount() const;
  void clear_fiforeservedeventcount();
  static const int kFifoReservedEventCountFieldNumber = 10;
  ::google::protobuf::uint32 fiforeservedeventcount() const;
  void set_fiforeservedeventcount(::google::protobuf::uint32 value);

  // required uint32 fifoMaxEventCount = 11;
  bool has_fifomaxeventcount() const;
  void clear_fifomaxeventcount();
  static const int kFifoMaxEventCountFieldNumber = 11;
  ::google::protobuf::uint32 fifomaxeventcount() const;
  void set_fifomaxeventcount(::google::protobuf::uint32 value);

  // required string stringType = 12;
  bool has_stringtype() const;
  void clear_stringtype();
  static const int kStringTypeFieldNumber = 12;
  const ::std::string& stringtype() const;
  void set_stringtype(const ::std::string& value);
  void set_stringtype(const char* value);
  void set_stringtype(const char* value, size_t size);
  ::std::string* mutable_stringtype();
  ::std::string* release_stringtype();
  void set_allocated_stringtype(::std::string* stringtype);

  // required string requiredPermission = 13;
  bool has_requiredpermission() const;
  void clear_requiredpermission();
  static const int kRequiredPermissionFieldNumber = 13;
  const ::std::string& requiredpermission() const;
  void set_requiredpermission(const ::std::string& value);
  void set_requiredpermission(const char* value);
  void set_requiredpermission(const char* value, size_t size);
  ::std::string* mutable_requiredpermission();
  ::std::string* release_requiredpermission();
  void set_allocated_requiredpermission(::std::string* requiredpermission);

  // required uint32 maxDelay = 14;
  bool has_maxdelay() const;
  void clear_maxdelay();
  static const int kMaxDelayFieldNumber = 14;
  ::google::protobuf::uint32 maxdelay() const;
  void set_maxdelay(::google::protobuf::uint32 value);

  // required uint32 flags = 15;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 15;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SensorService.Sensor)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_vendor();
  inline void clear_has_vendor();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_maxrange();
  inline void clear_has_maxrange();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_mindelay();
  inline void clear_has_mindelay();
  inline void set_has_fiforeservedeventcount();
  inline void clear_has_fiforeservedeventcount();
  inline void set_has_fifomaxeventcount();
  inline void clear_has_fifomaxeventcount();
  inline void set_has_stringtype();
  inline void clear_has_stringtype();
  inline void set_has_requiredpermission();
  inline void clear_has_requiredpermission();
  inline void set_has_maxdelay();
  inline void clear_has_maxdelay();
  inline void set_has_flags();
  inline void clear_has_flags();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr vendor_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 handle_;
  ::google::protobuf::int32 type_;
  float maxrange_;
  float resolution_;
  float power_;
  ::google::protobuf::int32 mindelay_;
  ::google::protobuf::uint32 fiforeservedeventcount_;
  ::google::protobuf::internal::ArenaStringPtr stringtype_;
  ::google::protobuf::uint32 fifomaxeventcount_;
  ::google::protobuf::uint32 maxdelay_;
  ::google::protobuf::internal::ArenaStringPtr requiredpermission_;
  ::google::protobuf::uint32 flags_;
  friend void  protobuf_AddDesc_SensorService_2eproto();
  friend void protobuf_AssignDesc_SensorService_2eproto();
  friend void protobuf_ShutdownFile_SensorService_2eproto();

  void InitAsDefaultInstance();
  static Sensor* default_instance_;
};
// -------------------------------------------------------------------

class SensorDataEvent : public ::google::protobuf::Message {
 public:
  SensorDataEvent();
  virtual ~SensorDataEvent();

  SensorDataEvent(const SensorDataEvent& from);

  inline SensorDataEvent& operator=(const SensorDataEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorDataEvent& default_instance();

  void Swap(SensorDataEvent* other);

  // implements Message ----------------------------------------------

  inline SensorDataEvent* New() const { return New(NULL); }

  SensorDataEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorDataEvent& from);
  void MergeFrom(const SensorDataEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SensorDataEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 accuracy = 1;
  bool has_accuracy() const;
  void clear_accuracy();
  static const int kAccuracyFieldNumber = 1;
  ::google::protobuf::int32 accuracy() const;
  void set_accuracy(::google::protobuf::int32 value);

  // required int32 sensorHandle = 2;
  bool has_sensorhandle() const;
  void clear_sensorhandle();
  static const int kSensorHandleFieldNumber = 2;
  ::google::protobuf::int32 sensorhandle() const;
  void set_sensorhandle(::google::protobuf::int32 value);

  // required int64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // required float xvalue = 4;
  bool has_xvalue() const;
  void clear_xvalue();
  static const int kXvalueFieldNumber = 4;
  float xvalue() const;
  void set_xvalue(float value);

  // optional float yvalue = 5;
  bool has_yvalue() const;
  void clear_yvalue();
  static const int kYvalueFieldNumber = 5;
  float yvalue() const;
  void set_yvalue(float value);

  // optional float zvalue = 6;
  bool has_zvalue() const;
  void clear_zvalue();
  static const int kZvalueFieldNumber = 6;
  float zvalue() const;
  void set_zvalue(float value);

  // @@protoc_insertion_point(class_scope:SensorService.SensorDataEvent)
 private:
  inline void set_has_accuracy();
  inline void clear_has_accuracy();
  inline void set_has_sensorhandle();
  inline void clear_has_sensorhandle();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_xvalue();
  inline void clear_has_xvalue();
  inline void set_has_yvalue();
  inline void clear_has_yvalue();
  inline void set_has_zvalue();
  inline void clear_has_zvalue();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 accuracy_;
  ::google::protobuf::int32 sensorhandle_;
  ::google::protobuf::int64 timestamp_;
  float xvalue_;
  float yvalue_;
  float zvalue_;
  friend void  protobuf_AddDesc_SensorService_2eproto();
  friend void protobuf_AssignDesc_SensorService_2eproto();
  friend void protobuf_ShutdownFile_SensorService_2eproto();

  void InitAsDefaultInstance();
  static SensorDataEvent* default_instance_;
};
// -------------------------------------------------------------------

class SensorAccuracyEvent : public ::google::protobuf::Message {
 public:
  SensorAccuracyEvent();
  virtual ~SensorAccuracyEvent();

  SensorAccuracyEvent(const SensorAccuracyEvent& from);

  inline SensorAccuracyEvent& operator=(const SensorAccuracyEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorAccuracyEvent& default_instance();

  void Swap(SensorAccuracyEvent* other);

  // implements Message ----------------------------------------------

  inline SensorAccuracyEvent* New() const { return New(NULL); }

  SensorAccuracyEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorAccuracyEvent& from);
  void MergeFrom(const SensorAccuracyEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SensorAccuracyEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 sensorHandle = 1;
  bool has_sensorhandle() const;
  void clear_sensorhandle();
  static const int kSensorHandleFieldNumber = 1;
  ::google::protobuf::int32 sensorhandle() const;
  void set_sensorhandle(::google::protobuf::int32 value);

  // required int32 accuracy = 2;
  bool has_accuracy() const;
  void clear_accuracy();
  static const int kAccuracyFieldNumber = 2;
  ::google::protobuf::int32 accuracy() const;
  void set_accuracy(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SensorService.SensorAccuracyEvent)
 private:
  inline void set_has_sensorhandle();
  inline void clear_has_sensorhandle();
  inline void set_has_accuracy();
  inline void clear_has_accuracy();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 sensorhandle_;
  ::google::protobuf::int32 accuracy_;
  friend void  protobuf_AddDesc_SensorService_2eproto();
  friend void protobuf_AssignDesc_SensorService_2eproto();
  friend void protobuf_ShutdownFile_SensorService_2eproto();

  void InitAsDefaultInstance();
  static SensorAccuracyEvent* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_RequestType RequestType;
  static const RequestType REGISTER = Request_RequestType_REGISTER;
  static const RequestType UNREGISTER = Request_RequestType_UNREGISTER;
  static const RequestType GET_SENSOR_LIST = Request_RequestType_GET_SENSOR_LIST;
  static inline bool RequestType_IsValid(int value) {
    return Request_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    Request_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    Request_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    Request_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return Request_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return Request_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return Request_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SensorService.Request.RequestType reqType = 1;
  bool has_reqtype() const;
  void clear_reqtype();
  static const int kReqTypeFieldNumber = 1;
  ::SensorService::Request_RequestType reqtype() const;
  void set_reqtype(::SensorService::Request_RequestType value);

  // optional .SensorService.RegisterListener regListener = 2;
  bool has_reglistener() const;
  void clear_reglistener();
  static const int kRegListenerFieldNumber = 2;
  const ::SensorService::RegisterListener& reglistener() const;
  ::SensorService::RegisterListener* mutable_reglistener();
  ::SensorService::RegisterListener* release_reglistener();
  void set_allocated_reglistener(::SensorService::RegisterListener* reglistener);

  // optional .SensorService.UnregisterListener unRegListener = 3;
  bool has_unreglistener() const;
  void clear_unreglistener();
  static const int kUnRegListenerFieldNumber = 3;
  const ::SensorService::UnregisterListener& unreglistener() const;
  ::SensorService::UnregisterListener* mutable_unreglistener();
  ::SensorService::UnregisterListener* release_unreglistener();
  void set_allocated_unreglistener(::SensorService::UnregisterListener* unreglistener);

  // @@protoc_insertion_point(class_scope:SensorService.Request)
 private:
  inline void set_has_reqtype();
  inline void clear_has_reqtype();
  inline void set_has_reglistener();
  inline void clear_has_reglistener();
  inline void set_has_unreglistener();
  inline void clear_has_unreglistener();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::SensorService::RegisterListener* reglistener_;
  ::SensorService::UnregisterListener* unreglistener_;
  int reqtype_;
  friend void  protobuf_AddDesc_SensorService_2eproto();
  friend void protobuf_AssignDesc_SensorService_2eproto();
  friend void protobuf_ShutdownFile_SensorService_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_ResponseType ResponseType;
  static const ResponseType SENSOR_LIST = Response_ResponseType_SENSOR_LIST;
  static const ResponseType SENSOR_DATA = Response_ResponseType_SENSOR_DATA;
  static const ResponseType SENSOR_ACCURACY = Response_ResponseType_SENSOR_ACCURACY;
  static inline bool ResponseType_IsValid(int value) {
    return Response_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    Response_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    Response_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    Response_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return Response_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return Response_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return Response_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SensorService.Response.ResponseType rspType = 1;
  bool has_rsptype() const;
  void clear_rsptype();
  static const int kRspTypeFieldNumber = 1;
  ::SensorService::Response_ResponseType rsptype() const;
  void set_rsptype(::SensorService::Response_ResponseType value);

  // repeated .SensorService.Sensor sensors = 2;
  int sensors_size() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 2;
  const ::SensorService::Sensor& sensors(int index) const;
  ::SensorService::Sensor* mutable_sensors(int index);
  ::SensorService::Sensor* add_sensors();
  ::google::protobuf::RepeatedPtrField< ::SensorService::Sensor >*
      mutable_sensors();
  const ::google::protobuf::RepeatedPtrField< ::SensorService::Sensor >&
      sensors() const;

  // optional .SensorService.SensorDataEvent sensorData = 3;
  bool has_sensordata() const;
  void clear_sensordata();
  static const int kSensorDataFieldNumber = 3;
  const ::SensorService::SensorDataEvent& sensordata() const;
  ::SensorService::SensorDataEvent* mutable_sensordata();
  ::SensorService::SensorDataEvent* release_sensordata();
  void set_allocated_sensordata(::SensorService::SensorDataEvent* sensordata);

  // optional .SensorService.SensorAccuracyEvent sensorAccuracy = 4;
  bool has_sensoraccuracy() const;
  void clear_sensoraccuracy();
  static const int kSensorAccuracyFieldNumber = 4;
  const ::SensorService::SensorAccuracyEvent& sensoraccuracy() const;
  ::SensorService::SensorAccuracyEvent* mutable_sensoraccuracy();
  ::SensorService::SensorAccuracyEvent* release_sensoraccuracy();
  void set_allocated_sensoraccuracy(::SensorService::SensorAccuracyEvent* sensoraccuracy);

  // @@protoc_insertion_point(class_scope:SensorService.Response)
 private:
  inline void set_has_rsptype();
  inline void clear_has_rsptype();
  inline void set_has_sensordata();
  inline void clear_has_sensordata();
  inline void set_has_sensoraccuracy();
  inline void clear_has_sensoraccuracy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SensorService::Sensor > sensors_;
  ::SensorService::SensorDataEvent* sensordata_;
  ::SensorService::SensorAccuracyEvent* sensoraccuracy_;
  int rsptype_;
  friend void  protobuf_AddDesc_SensorService_2eproto();
  friend void protobuf_AssignDesc_SensorService_2eproto();
  friend void protobuf_ShutdownFile_SensorService_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterListener

// required .SensorService.RegisterListener.RegisterType type = 1;
inline bool RegisterListener::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterListener::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterListener::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterListener::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SensorService::RegisterListener_RegisterType RegisterListener::type() const {
  // @@protoc_insertion_point(field_get:SensorService.RegisterListener.type)
  return static_cast< ::SensorService::RegisterListener_RegisterType >(type_);
}
inline void RegisterListener::set_type(::SensorService::RegisterListener_RegisterType value) {
  assert(::SensorService::RegisterListener_RegisterType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SensorService.RegisterListener.type)
}

// required int32 sensorHandle = 2;
inline bool RegisterListener::has_sensorhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterListener::set_has_sensorhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterListener::clear_has_sensorhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterListener::clear_sensorhandle() {
  sensorhandle_ = 0;
  clear_has_sensorhandle();
}
inline ::google::protobuf::int32 RegisterListener::sensorhandle() const {
  // @@protoc_insertion_point(field_get:SensorService.RegisterListener.sensorHandle)
  return sensorhandle_;
}
inline void RegisterListener::set_sensorhandle(::google::protobuf::int32 value) {
  set_has_sensorhandle();
  sensorhandle_ = value;
  // @@protoc_insertion_point(field_set:SensorService.RegisterListener.sensorHandle)
}

// optional int32 samplingPeriodUs = 3;
inline bool RegisterListener::has_samplingperiodus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterListener::set_has_samplingperiodus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterListener::clear_has_samplingperiodus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterListener::clear_samplingperiodus() {
  samplingperiodus_ = 0;
  clear_has_samplingperiodus();
}
inline ::google::protobuf::int32 RegisterListener::samplingperiodus() const {
  // @@protoc_insertion_point(field_get:SensorService.RegisterListener.samplingPeriodUs)
  return samplingperiodus_;
}
inline void RegisterListener::set_samplingperiodus(::google::protobuf::int32 value) {
  set_has_samplingperiodus();
  samplingperiodus_ = value;
  // @@protoc_insertion_point(field_set:SensorService.RegisterListener.samplingPeriodUs)
}

// optional int32 maxReportLatencyUs = 4;
inline bool RegisterListener::has_maxreportlatencyus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterListener::set_has_maxreportlatencyus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterListener::clear_has_maxreportlatencyus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterListener::clear_maxreportlatencyus() {
  maxreportlatencyus_ = 0;
  clear_has_maxreportlatencyus();
}
inline ::google::protobuf::int32 RegisterListener::maxreportlatencyus() const {
  // @@protoc_insertion_point(field_get:SensorService.RegisterListener.maxReportLatencyUs)
  return maxreportlatencyus_;
}
inline void RegisterListener::set_maxreportlatencyus(::google::protobuf::int32 value) {
  set_has_maxreportlatencyus();
  maxreportlatencyus_ = value;
  // @@protoc_insertion_point(field_set:SensorService.RegisterListener.maxReportLatencyUs)
}

// -------------------------------------------------------------------

// UnregisterListener

// required int32 sensorHandle = 1;
inline bool UnregisterListener::has_sensorhandle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterListener::set_has_sensorhandle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterListener::clear_has_sensorhandle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterListener::clear_sensorhandle() {
  sensorhandle_ = 0;
  clear_has_sensorhandle();
}
inline ::google::protobuf::int32 UnregisterListener::sensorhandle() const {
  // @@protoc_insertion_point(field_get:SensorService.UnregisterListener.sensorHandle)
  return sensorhandle_;
}
inline void UnregisterListener::set_sensorhandle(::google::protobuf::int32 value) {
  set_has_sensorhandle();
  sensorhandle_ = value;
  // @@protoc_insertion_point(field_set:SensorService.UnregisterListener.sensorHandle)
}

// -------------------------------------------------------------------

// Sensor

// required string name = 1;
inline bool Sensor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sensor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sensor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sensor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Sensor::name() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SensorService.Sensor.name)
}
inline void Sensor::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SensorService.Sensor.name)
}
inline void Sensor::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SensorService.Sensor.name)
}
inline ::std::string* Sensor::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:SensorService.Sensor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SensorService.Sensor.name)
}

// required string vendor = 2;
inline bool Sensor::has_vendor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sensor::set_has_vendor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sensor::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sensor::clear_vendor() {
  vendor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vendor();
}
inline const ::std::string& Sensor::vendor() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.vendor)
  return vendor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_vendor(const ::std::string& value) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SensorService.Sensor.vendor)
}
inline void Sensor::set_vendor(const char* value) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SensorService.Sensor.vendor)
}
inline void Sensor::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SensorService.Sensor.vendor)
}
inline ::std::string* Sensor::mutable_vendor() {
  set_has_vendor();
  // @@protoc_insertion_point(field_mutable:SensorService.Sensor.vendor)
  return vendor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_vendor() {
  clear_has_vendor();
  return vendor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_vendor(::std::string* vendor) {
  if (vendor != NULL) {
    set_has_vendor();
  } else {
    clear_has_vendor();
  }
  vendor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vendor);
  // @@protoc_insertion_point(field_set_allocated:SensorService.Sensor.vendor)
}

// required int32 version = 3;
inline bool Sensor::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sensor::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sensor::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sensor::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Sensor::version() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.version)
  return version_;
}
inline void Sensor::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.version)
}

// required int32 handle = 4;
inline bool Sensor::has_handle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Sensor::set_has_handle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Sensor::clear_has_handle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Sensor::clear_handle() {
  handle_ = 0;
  clear_has_handle();
}
inline ::google::protobuf::int32 Sensor::handle() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.handle)
  return handle_;
}
inline void Sensor::set_handle(::google::protobuf::int32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.handle)
}

// required int32 type = 5;
inline bool Sensor::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Sensor::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Sensor::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Sensor::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Sensor::type() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.type)
  return type_;
}
inline void Sensor::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.type)
}

// required float maxRange = 6;
inline bool Sensor::has_maxrange() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Sensor::set_has_maxrange() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Sensor::clear_has_maxrange() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Sensor::clear_maxrange() {
  maxrange_ = 0;
  clear_has_maxrange();
}
inline float Sensor::maxrange() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.maxRange)
  return maxrange_;
}
inline void Sensor::set_maxrange(float value) {
  set_has_maxrange();
  maxrange_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.maxRange)
}

// required float resolution = 7;
inline bool Sensor::has_resolution() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Sensor::set_has_resolution() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Sensor::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Sensor::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline float Sensor::resolution() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.resolution)
  return resolution_;
}
inline void Sensor::set_resolution(float value) {
  set_has_resolution();
  resolution_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.resolution)
}

// required float power = 8;
inline bool Sensor::has_power() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Sensor::set_has_power() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Sensor::clear_has_power() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Sensor::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline float Sensor::power() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.power)
  return power_;
}
inline void Sensor::set_power(float value) {
  set_has_power();
  power_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.power)
}

// required int32 minDelay = 9;
inline bool Sensor::has_mindelay() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Sensor::set_has_mindelay() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Sensor::clear_has_mindelay() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Sensor::clear_mindelay() {
  mindelay_ = 0;
  clear_has_mindelay();
}
inline ::google::protobuf::int32 Sensor::mindelay() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.minDelay)
  return mindelay_;
}
inline void Sensor::set_mindelay(::google::protobuf::int32 value) {
  set_has_mindelay();
  mindelay_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.minDelay)
}

// required uint32 fifoReservedEventCount = 10;
inline bool Sensor::has_fiforeservedeventcount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Sensor::set_has_fiforeservedeventcount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Sensor::clear_has_fiforeservedeventcount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Sensor::clear_fiforeservedeventcount() {
  fiforeservedeventcount_ = 0u;
  clear_has_fiforeservedeventcount();
}
inline ::google::protobuf::uint32 Sensor::fiforeservedeventcount() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.fifoReservedEventCount)
  return fiforeservedeventcount_;
}
inline void Sensor::set_fiforeservedeventcount(::google::protobuf::uint32 value) {
  set_has_fiforeservedeventcount();
  fiforeservedeventcount_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.fifoReservedEventCount)
}

// required uint32 fifoMaxEventCount = 11;
inline bool Sensor::has_fifomaxeventcount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Sensor::set_has_fifomaxeventcount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Sensor::clear_has_fifomaxeventcount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Sensor::clear_fifomaxeventcount() {
  fifomaxeventcount_ = 0u;
  clear_has_fifomaxeventcount();
}
inline ::google::protobuf::uint32 Sensor::fifomaxeventcount() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.fifoMaxEventCount)
  return fifomaxeventcount_;
}
inline void Sensor::set_fifomaxeventcount(::google::protobuf::uint32 value) {
  set_has_fifomaxeventcount();
  fifomaxeventcount_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.fifoMaxEventCount)
}

// required string stringType = 12;
inline bool Sensor::has_stringtype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Sensor::set_has_stringtype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Sensor::clear_has_stringtype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Sensor::clear_stringtype() {
  stringtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_stringtype();
}
inline const ::std::string& Sensor::stringtype() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.stringType)
  return stringtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_stringtype(const ::std::string& value) {
  set_has_stringtype();
  stringtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SensorService.Sensor.stringType)
}
inline void Sensor::set_stringtype(const char* value) {
  set_has_stringtype();
  stringtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SensorService.Sensor.stringType)
}
inline void Sensor::set_stringtype(const char* value, size_t size) {
  set_has_stringtype();
  stringtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SensorService.Sensor.stringType)
}
inline ::std::string* Sensor::mutable_stringtype() {
  set_has_stringtype();
  // @@protoc_insertion_point(field_mutable:SensorService.Sensor.stringType)
  return stringtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_stringtype() {
  clear_has_stringtype();
  return stringtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_stringtype(::std::string* stringtype) {
  if (stringtype != NULL) {
    set_has_stringtype();
  } else {
    clear_has_stringtype();
  }
  stringtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stringtype);
  // @@protoc_insertion_point(field_set_allocated:SensorService.Sensor.stringType)
}

// required string requiredPermission = 13;
inline bool Sensor::has_requiredpermission() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Sensor::set_has_requiredpermission() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Sensor::clear_has_requiredpermission() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Sensor::clear_requiredpermission() {
  requiredpermission_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_requiredpermission();
}
inline const ::std::string& Sensor::requiredpermission() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.requiredPermission)
  return requiredpermission_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_requiredpermission(const ::std::string& value) {
  set_has_requiredpermission();
  requiredpermission_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SensorService.Sensor.requiredPermission)
}
inline void Sensor::set_requiredpermission(const char* value) {
  set_has_requiredpermission();
  requiredpermission_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SensorService.Sensor.requiredPermission)
}
inline void Sensor::set_requiredpermission(const char* value, size_t size) {
  set_has_requiredpermission();
  requiredpermission_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SensorService.Sensor.requiredPermission)
}
inline ::std::string* Sensor::mutable_requiredpermission() {
  set_has_requiredpermission();
  // @@protoc_insertion_point(field_mutable:SensorService.Sensor.requiredPermission)
  return requiredpermission_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_requiredpermission() {
  clear_has_requiredpermission();
  return requiredpermission_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_requiredpermission(::std::string* requiredpermission) {
  if (requiredpermission != NULL) {
    set_has_requiredpermission();
  } else {
    clear_has_requiredpermission();
  }
  requiredpermission_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requiredpermission);
  // @@protoc_insertion_point(field_set_allocated:SensorService.Sensor.requiredPermission)
}

// required uint32 maxDelay = 14;
inline bool Sensor::has_maxdelay() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Sensor::set_has_maxdelay() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Sensor::clear_has_maxdelay() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Sensor::clear_maxdelay() {
  maxdelay_ = 0u;
  clear_has_maxdelay();
}
inline ::google::protobuf::uint32 Sensor::maxdelay() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.maxDelay)
  return maxdelay_;
}
inline void Sensor::set_maxdelay(::google::protobuf::uint32 value) {
  set_has_maxdelay();
  maxdelay_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.maxDelay)
}

// required uint32 flags = 15;
inline bool Sensor::has_flags() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Sensor::set_has_flags() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Sensor::clear_has_flags() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Sensor::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 Sensor::flags() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.flags)
  return flags_;
}
inline void Sensor::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.flags)
}

// -------------------------------------------------------------------

// SensorDataEvent

// required int32 accuracy = 1;
inline bool SensorDataEvent::has_accuracy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorDataEvent::set_has_accuracy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorDataEvent::clear_has_accuracy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorDataEvent::clear_accuracy() {
  accuracy_ = 0;
  clear_has_accuracy();
}
inline ::google::protobuf::int32 SensorDataEvent::accuracy() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.accuracy)
  return accuracy_;
}
inline void SensorDataEvent::set_accuracy(::google::protobuf::int32 value) {
  set_has_accuracy();
  accuracy_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.accuracy)
}

// required int32 sensorHandle = 2;
inline bool SensorDataEvent::has_sensorhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorDataEvent::set_has_sensorhandle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorDataEvent::clear_has_sensorhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorDataEvent::clear_sensorhandle() {
  sensorhandle_ = 0;
  clear_has_sensorhandle();
}
inline ::google::protobuf::int32 SensorDataEvent::sensorhandle() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.sensorHandle)
  return sensorhandle_;
}
inline void SensorDataEvent::set_sensorhandle(::google::protobuf::int32 value) {
  set_has_sensorhandle();
  sensorhandle_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.sensorHandle)
}

// required int64 timestamp = 3;
inline bool SensorDataEvent::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorDataEvent::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorDataEvent::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorDataEvent::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 SensorDataEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.timestamp)
  return timestamp_;
}
inline void SensorDataEvent::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.timestamp)
}

// required float xvalue = 4;
inline bool SensorDataEvent::has_xvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorDataEvent::set_has_xvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorDataEvent::clear_has_xvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorDataEvent::clear_xvalue() {
  xvalue_ = 0;
  clear_has_xvalue();
}
inline float SensorDataEvent::xvalue() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.xvalue)
  return xvalue_;
}
inline void SensorDataEvent::set_xvalue(float value) {
  set_has_xvalue();
  xvalue_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.xvalue)
}

// optional float yvalue = 5;
inline bool SensorDataEvent::has_yvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorDataEvent::set_has_yvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorDataEvent::clear_has_yvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorDataEvent::clear_yvalue() {
  yvalue_ = 0;
  clear_has_yvalue();
}
inline float SensorDataEvent::yvalue() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.yvalue)
  return yvalue_;
}
inline void SensorDataEvent::set_yvalue(float value) {
  set_has_yvalue();
  yvalue_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.yvalue)
}

// optional float zvalue = 6;
inline bool SensorDataEvent::has_zvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorDataEvent::set_has_zvalue() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorDataEvent::clear_has_zvalue() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorDataEvent::clear_zvalue() {
  zvalue_ = 0;
  clear_has_zvalue();
}
inline float SensorDataEvent::zvalue() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.zvalue)
  return zvalue_;
}
inline void SensorDataEvent::set_zvalue(float value) {
  set_has_zvalue();
  zvalue_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.zvalue)
}

// -------------------------------------------------------------------

// SensorAccuracyEvent

// required int32 sensorHandle = 1;
inline bool SensorAccuracyEvent::has_sensorhandle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorAccuracyEvent::set_has_sensorhandle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorAccuracyEvent::clear_has_sensorhandle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorAccuracyEvent::clear_sensorhandle() {
  sensorhandle_ = 0;
  clear_has_sensorhandle();
}
inline ::google::protobuf::int32 SensorAccuracyEvent::sensorhandle() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorAccuracyEvent.sensorHandle)
  return sensorhandle_;
}
inline void SensorAccuracyEvent::set_sensorhandle(::google::protobuf::int32 value) {
  set_has_sensorhandle();
  sensorhandle_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorAccuracyEvent.sensorHandle)
}

// required int32 accuracy = 2;
inline bool SensorAccuracyEvent::has_accuracy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorAccuracyEvent::set_has_accuracy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorAccuracyEvent::clear_has_accuracy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorAccuracyEvent::clear_accuracy() {
  accuracy_ = 0;
  clear_has_accuracy();
}
inline ::google::protobuf::int32 SensorAccuracyEvent::accuracy() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorAccuracyEvent.accuracy)
  return accuracy_;
}
inline void SensorAccuracyEvent::set_accuracy(::google::protobuf::int32 value) {
  set_has_accuracy();
  accuracy_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorAccuracyEvent.accuracy)
}

// -------------------------------------------------------------------

// Request

// required .SensorService.Request.RequestType reqType = 1;
inline bool Request::has_reqtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_reqtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_reqtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_reqtype() {
  reqtype_ = 0;
  clear_has_reqtype();
}
inline ::SensorService::Request_RequestType Request::reqtype() const {
  // @@protoc_insertion_point(field_get:SensorService.Request.reqType)
  return static_cast< ::SensorService::Request_RequestType >(reqtype_);
}
inline void Request::set_reqtype(::SensorService::Request_RequestType value) {
  assert(::SensorService::Request_RequestType_IsValid(value));
  set_has_reqtype();
  reqtype_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Request.reqType)
}

// optional .SensorService.RegisterListener regListener = 2;
inline bool Request::has_reglistener() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_reglistener() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_reglistener() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_reglistener() {
  if (reglistener_ != NULL) reglistener_->::SensorService::RegisterListener::Clear();
  clear_has_reglistener();
}
inline const ::SensorService::RegisterListener& Request::reglistener() const {
  // @@protoc_insertion_point(field_get:SensorService.Request.regListener)
  return reglistener_ != NULL ? *reglistener_ : *default_instance_->reglistener_;
}
inline ::SensorService::RegisterListener* Request::mutable_reglistener() {
  set_has_reglistener();
  if (reglistener_ == NULL) {
    reglistener_ = new ::SensorService::RegisterListener;
  }
  // @@protoc_insertion_point(field_mutable:SensorService.Request.regListener)
  return reglistener_;
}
inline ::SensorService::RegisterListener* Request::release_reglistener() {
  clear_has_reglistener();
  ::SensorService::RegisterListener* temp = reglistener_;
  reglistener_ = NULL;
  return temp;
}
inline void Request::set_allocated_reglistener(::SensorService::RegisterListener* reglistener) {
  delete reglistener_;
  reglistener_ = reglistener;
  if (reglistener) {
    set_has_reglistener();
  } else {
    clear_has_reglistener();
  }
  // @@protoc_insertion_point(field_set_allocated:SensorService.Request.regListener)
}

// optional .SensorService.UnregisterListener unRegListener = 3;
inline bool Request::has_unreglistener() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_unreglistener() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_unreglistener() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_unreglistener() {
  if (unreglistener_ != NULL) unreglistener_->::SensorService::UnregisterListener::Clear();
  clear_has_unreglistener();
}
inline const ::SensorService::UnregisterListener& Request::unreglistener() const {
  // @@protoc_insertion_point(field_get:SensorService.Request.unRegListener)
  return unreglistener_ != NULL ? *unreglistener_ : *default_instance_->unreglistener_;
}
inline ::SensorService::UnregisterListener* Request::mutable_unreglistener() {
  set_has_unreglistener();
  if (unreglistener_ == NULL) {
    unreglistener_ = new ::SensorService::UnregisterListener;
  }
  // @@protoc_insertion_point(field_mutable:SensorService.Request.unRegListener)
  return unreglistener_;
}
inline ::SensorService::UnregisterListener* Request::release_unreglistener() {
  clear_has_unreglistener();
  ::SensorService::UnregisterListener* temp = unreglistener_;
  unreglistener_ = NULL;
  return temp;
}
inline void Request::set_allocated_unreglistener(::SensorService::UnregisterListener* unreglistener) {
  delete unreglistener_;
  unreglistener_ = unreglistener;
  if (unreglistener) {
    set_has_unreglistener();
  } else {
    clear_has_unreglistener();
  }
  // @@protoc_insertion_point(field_set_allocated:SensorService.Request.unRegListener)
}

// -------------------------------------------------------------------

// Response

// required .SensorService.Response.ResponseType rspType = 1;
inline bool Response::has_rsptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_rsptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_rsptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_rsptype() {
  rsptype_ = 0;
  clear_has_rsptype();
}
inline ::SensorService::Response_ResponseType Response::rsptype() const {
  // @@protoc_insertion_point(field_get:SensorService.Response.rspType)
  return static_cast< ::SensorService::Response_ResponseType >(rsptype_);
}
inline void Response::set_rsptype(::SensorService::Response_ResponseType value) {
  assert(::SensorService::Response_ResponseType_IsValid(value));
  set_has_rsptype();
  rsptype_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Response.rspType)
}

// repeated .SensorService.Sensor sensors = 2;
inline int Response::sensors_size() const {
  return sensors_.size();
}
inline void Response::clear_sensors() {
  sensors_.Clear();
}
inline const ::SensorService::Sensor& Response::sensors(int index) const {
  // @@protoc_insertion_point(field_get:SensorService.Response.sensors)
  return sensors_.Get(index);
}
inline ::SensorService::Sensor* Response::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:SensorService.Response.sensors)
  return sensors_.Mutable(index);
}
inline ::SensorService::Sensor* Response::add_sensors() {
  // @@protoc_insertion_point(field_add:SensorService.Response.sensors)
  return sensors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::SensorService::Sensor >*
Response::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:SensorService.Response.sensors)
  return &sensors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::SensorService::Sensor >&
Response::sensors() const {
  // @@protoc_insertion_point(field_list:SensorService.Response.sensors)
  return sensors_;
}

// optional .SensorService.SensorDataEvent sensorData = 3;
inline bool Response::has_sensordata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_sensordata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_sensordata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_sensordata() {
  if (sensordata_ != NULL) sensordata_->::SensorService::SensorDataEvent::Clear();
  clear_has_sensordata();
}
inline const ::SensorService::SensorDataEvent& Response::sensordata() const {
  // @@protoc_insertion_point(field_get:SensorService.Response.sensorData)
  return sensordata_ != NULL ? *sensordata_ : *default_instance_->sensordata_;
}
inline ::SensorService::SensorDataEvent* Response::mutable_sensordata() {
  set_has_sensordata();
  if (sensordata_ == NULL) {
    sensordata_ = new ::SensorService::SensorDataEvent;
  }
  // @@protoc_insertion_point(field_mutable:SensorService.Response.sensorData)
  return sensordata_;
}
inline ::SensorService::SensorDataEvent* Response::release_sensordata() {
  clear_has_sensordata();
  ::SensorService::SensorDataEvent* temp = sensordata_;
  sensordata_ = NULL;
  return temp;
}
inline void Response::set_allocated_sensordata(::SensorService::SensorDataEvent* sensordata) {
  delete sensordata_;
  sensordata_ = sensordata;
  if (sensordata) {
    set_has_sensordata();
  } else {
    clear_has_sensordata();
  }
  // @@protoc_insertion_point(field_set_allocated:SensorService.Response.sensorData)
}

// optional .SensorService.SensorAccuracyEvent sensorAccuracy = 4;
inline bool Response::has_sensoraccuracy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_sensoraccuracy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_sensoraccuracy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_sensoraccuracy() {
  if (sensoraccuracy_ != NULL) sensoraccuracy_->::SensorService::SensorAccuracyEvent::Clear();
  clear_has_sensoraccuracy();
}
inline const ::SensorService::SensorAccuracyEvent& Response::sensoraccuracy() const {
  // @@protoc_insertion_point(field_get:SensorService.Response.sensorAccuracy)
  return sensoraccuracy_ != NULL ? *sensoraccuracy_ : *default_instance_->sensoraccuracy_;
}
inline ::SensorService::SensorAccuracyEvent* Response::mutable_sensoraccuracy() {
  set_has_sensoraccuracy();
  if (sensoraccuracy_ == NULL) {
    sensoraccuracy_ = new ::SensorService::SensorAccuracyEvent;
  }
  // @@protoc_insertion_point(field_mutable:SensorService.Response.sensorAccuracy)
  return sensoraccuracy_;
}
inline ::SensorService::SensorAccuracyEvent* Response::release_sensoraccuracy() {
  clear_has_sensoraccuracy();
  ::SensorService::SensorAccuracyEvent* temp = sensoraccuracy_;
  sensoraccuracy_ = NULL;
  return temp;
}
inline void Response::set_allocated_sensoraccuracy(::SensorService::SensorAccuracyEvent* sensoraccuracy) {
  delete sensoraccuracy_;
  sensoraccuracy_ = sensoraccuracy;
  if (sensoraccuracy) {
    set_has_sensoraccuracy();
  } else {
    clear_has_sensoraccuracy();
  }
  // @@protoc_insertion_point(field_set_allocated:SensorService.Response.sensorAccuracy)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SensorService

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SensorService::RegisterListener_RegisterType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorService::RegisterListener_RegisterType>() {
  return ::SensorService::RegisterListener_RegisterType_descriptor();
}
template <> struct is_proto_enum< ::SensorService::Request_RequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorService::Request_RequestType>() {
  return ::SensorService::Request_RequestType_descriptor();
}
template <> struct is_proto_enum< ::SensorService::Response_ResponseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorService::Response_ResponseType>() {
  return ::SensorService::Response_ResponseType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SensorService_2eproto__INCLUDED
