// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SensorService.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "SensorService.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace SensorService {

namespace {

const ::google::protobuf::Descriptor* RegisterListener_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterListener_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RegisterListener_RegisterType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* UnregisterListener_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnregisterListener_reflection_ = NULL;
const ::google::protobuf::Descriptor* Sensor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sensor_reflection_ = NULL;
const ::google::protobuf::Descriptor* SensorDataEvent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SensorDataEvent_reflection_ = NULL;
const ::google::protobuf::Descriptor* SensorAccuracyEvent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SensorAccuracyEvent_reflection_ = NULL;
const ::google::protobuf::Descriptor* Request_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Request_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Request_RequestType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Response_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Response_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_SensorService_2eproto() {
  protobuf_AddDesc_SensorService_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "SensorService.proto");
  GOOGLE_CHECK(file != NULL);
  RegisterListener_descriptor_ = file->message_type(0);
  static const int RegisterListener_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterListener, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterListener, sensorhandle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterListener, samplingperiodus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterListener, maxreportlatencyus_),
  };
  RegisterListener_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RegisterListener_descriptor_,
      RegisterListener::default_instance_,
      RegisterListener_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterListener, _has_bits_[0]),
      -1,
      -1,
      sizeof(RegisterListener),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterListener, _internal_metadata_),
      -1);
  RegisterListener_RegisterType_descriptor_ = RegisterListener_descriptor_->enum_type(0);
  UnregisterListener_descriptor_ = file->message_type(1);
  static const int UnregisterListener_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterListener, sensorhandle_),
  };
  UnregisterListener_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      UnregisterListener_descriptor_,
      UnregisterListener::default_instance_,
      UnregisterListener_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterListener, _has_bits_[0]),
      -1,
      -1,
      sizeof(UnregisterListener),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnregisterListener, _internal_metadata_),
      -1);
  Sensor_descriptor_ = file->message_type(2);
  static const int Sensor_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, vendor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, handle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, maxrange_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, resolution_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, power_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, mindelay_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, fiforeservedeventcount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, fifomaxeventcount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, stringtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, requiredpermission_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, maxdelay_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, flags_),
  };
  Sensor_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Sensor_descriptor_,
      Sensor::default_instance_,
      Sensor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, _has_bits_[0]),
      -1,
      -1,
      sizeof(Sensor),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, _internal_metadata_),
      -1);
  SensorDataEvent_descriptor_ = file->message_type(3);
  static const int SensorDataEvent_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDataEvent, accuracy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDataEvent, sensorhandle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDataEvent, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDataEvent, xvalue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDataEvent, yvalue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDataEvent, zvalue_),
  };
  SensorDataEvent_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SensorDataEvent_descriptor_,
      SensorDataEvent::default_instance_,
      SensorDataEvent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDataEvent, _has_bits_[0]),
      -1,
      -1,
      sizeof(SensorDataEvent),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDataEvent, _internal_metadata_),
      -1);
  SensorAccuracyEvent_descriptor_ = file->message_type(4);
  static const int SensorAccuracyEvent_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorAccuracyEvent, sensorhandle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorAccuracyEvent, accuracy_),
  };
  SensorAccuracyEvent_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SensorAccuracyEvent_descriptor_,
      SensorAccuracyEvent::default_instance_,
      SensorAccuracyEvent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorAccuracyEvent, _has_bits_[0]),
      -1,
      -1,
      sizeof(SensorAccuracyEvent),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorAccuracyEvent, _internal_metadata_),
      -1);
  Request_descriptor_ = file->message_type(5);
  static const int Request_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, reqtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, reglistener_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, unreglistener_),
  };
  Request_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Request_descriptor_,
      Request::default_instance_,
      Request_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, _has_bits_[0]),
      -1,
      -1,
      sizeof(Request),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, _internal_metadata_),
      -1);
  Request_RequestType_descriptor_ = Request_descriptor_->enum_type(0);
  Response_descriptor_ = file->message_type(6);
  static const int Response_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, rsptype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, sensors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, sensordata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, sensoraccuracy_),
  };
  Response_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Response_descriptor_,
      Response::default_instance_,
      Response_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, _has_bits_[0]),
      -1,
      -1,
      sizeof(Response),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, _internal_metadata_),
      -1);
  Response_ResponseType_descriptor_ = Response_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_SensorService_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RegisterListener_descriptor_, &RegisterListener::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      UnregisterListener_descriptor_, &UnregisterListener::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Sensor_descriptor_, &Sensor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SensorDataEvent_descriptor_, &SensorDataEvent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SensorAccuracyEvent_descriptor_, &SensorAccuracyEvent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Request_descriptor_, &Request::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Response_descriptor_, &Response::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_SensorService_2eproto() {
  delete RegisterListener::default_instance_;
  delete RegisterListener_reflection_;
  delete UnregisterListener::default_instance_;
  delete UnregisterListener_reflection_;
  delete Sensor::default_instance_;
  delete Sensor_reflection_;
  delete SensorDataEvent::default_instance_;
  delete SensorDataEvent_reflection_;
  delete SensorAccuracyEvent::default_instance_;
  delete SensorAccuracyEvent_reflection_;
  delete Request::default_instance_;
  delete Request_reflection_;
  delete Response::default_instance_;
  delete Response_reflection_;
}

void protobuf_AddDesc_SensorService_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\023SensorService.proto\022\rSensorService\"\303\001\n"
    "\020RegisterListener\022:\n\004type\030\001 \002(\0162,.Sensor"
    "Service.RegisterListener.RegisterType\022\024\n"
    "\014sensorHandle\030\002 \002(\005\022\030\n\020samplingPeriodUs\030"
    "\003 \001(\005\022\032\n\022maxReportLatencyUs\030\004 \001(\005\"\'\n\014Reg"
    "isterType\022\n\n\006STREAM\020\000\022\013\n\007TRIGGER\020\001\"*\n\022Un"
    "registerListener\022\024\n\014sensorHandle\030\001 \002(\005\"\250"
    "\002\n\006Sensor\022\014\n\004name\030\001 \002(\t\022\016\n\006vendor\030\002 \002(\t\022"
    "\017\n\007version\030\003 \002(\005\022\016\n\006handle\030\004 \002(\005\022\014\n\004type"
    "\030\005 \002(\005\022\020\n\010maxRange\030\006 \002(\002\022\022\n\nresolution\030\007"
    " \002(\002\022\r\n\005power\030\010 \002(\002\022\020\n\010minDelay\030\t \002(\005\022\036\n"
    "\026fifoReservedEventCount\030\n \002(\r\022\031\n\021fifoMax"
    "EventCount\030\013 \002(\r\022\022\n\nstringType\030\014 \002(\t\022\032\n\022"
    "requiredPermission\030\r \002(\t\022\020\n\010maxDelay\030\016 \002"
    "(\r\022\r\n\005flags\030\017 \002(\r\"|\n\017SensorDataEvent\022\020\n\010"
    "accuracy\030\001 \002(\005\022\024\n\014sensorHandle\030\002 \002(\005\022\021\n\t"
    "timestamp\030\003 \002(\003\022\016\n\006xvalue\030\004 \002(\002\022\016\n\006yvalu"
    "e\030\005 \001(\002\022\016\n\006zvalue\030\006 \001(\002\"=\n\023SensorAccurac"
    "yEvent\022\024\n\014sensorHandle\030\001 \002(\005\022\020\n\010accuracy"
    "\030\002 \002(\005\"\360\001\n\007Request\0223\n\007reqType\030\001 \002(\0162\".Se"
    "nsorService.Request.RequestType\0224\n\013regLi"
    "stener\030\002 \001(\0132\037.SensorService.RegisterLis"
    "tener\0228\n\runRegListener\030\003 \001(\0132!.SensorSer"
    "vice.UnregisterListener\"@\n\013RequestType\022\014"
    "\n\010REGISTER\020\000\022\016\n\nUNREGISTER\020\001\022\023\n\017GET_SENS"
    "OR_LIST\020\002\"\240\002\n\010Response\0225\n\007rspType\030\001 \002(\0162"
    "$.SensorService.Response.ResponseType\022&\n"
    "\007sensors\030\002 \003(\0132\025.SensorService.Sensor\0222\n"
    "\nsensorData\030\003 \001(\0132\036.SensorService.Sensor"
    "DataEvent\022:\n\016sensorAccuracy\030\004 \001(\0132\".Sens"
    "orService.SensorAccuracyEvent\"E\n\014Respons"
    "eType\022\017\n\013SENSOR_LIST\020\000\022\017\n\013SENSOR_DATA\020\001\022"
    "\023\n\017SENSOR_ACCURACY\020\002B1\n\033cn.ac.iscas.sens"
    "orcollectorB\022SenserServiceProto", 1351);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "SensorService.proto", &protobuf_RegisterTypes);
  RegisterListener::default_instance_ = new RegisterListener();
  UnregisterListener::default_instance_ = new UnregisterListener();
  Sensor::default_instance_ = new Sensor();
  SensorDataEvent::default_instance_ = new SensorDataEvent();
  SensorAccuracyEvent::default_instance_ = new SensorAccuracyEvent();
  Request::default_instance_ = new Request();
  Response::default_instance_ = new Response();
  RegisterListener::default_instance_->InitAsDefaultInstance();
  UnregisterListener::default_instance_->InitAsDefaultInstance();
  Sensor::default_instance_->InitAsDefaultInstance();
  SensorDataEvent::default_instance_->InitAsDefaultInstance();
  SensorAccuracyEvent::default_instance_->InitAsDefaultInstance();
  Request::default_instance_->InitAsDefaultInstance();
  Response::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_SensorService_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_SensorService_2eproto {
  StaticDescriptorInitializer_SensorService_2eproto() {
    protobuf_AddDesc_SensorService_2eproto();
  }
} static_descriptor_initializer_SensorService_2eproto_;

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

const ::google::protobuf::EnumDescriptor* RegisterListener_RegisterType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterListener_RegisterType_descriptor_;
}
bool RegisterListener_RegisterType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const RegisterListener_RegisterType RegisterListener::STREAM;
const RegisterListener_RegisterType RegisterListener::TRIGGER;
const RegisterListener_RegisterType RegisterListener::RegisterType_MIN;
const RegisterListener_RegisterType RegisterListener::RegisterType_MAX;
const int RegisterListener::RegisterType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int RegisterListener::kTypeFieldNumber;
const int RegisterListener::kSensorHandleFieldNumber;
const int RegisterListener::kSamplingPeriodUsFieldNumber;
const int RegisterListener::kMaxReportLatencyUsFieldNumber;
#endif  // !_MSC_VER

RegisterListener::RegisterListener()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorService.RegisterListener)
}

void RegisterListener::InitAsDefaultInstance() {
}

RegisterListener::RegisterListener(const RegisterListener& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorService.RegisterListener)
}

void RegisterListener::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  sensorhandle_ = 0;
  samplingperiodus_ = 0;
  maxreportlatencyus_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterListener::~RegisterListener() {
  // @@protoc_insertion_point(destructor:SensorService.RegisterListener)
  SharedDtor();
}

void RegisterListener::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RegisterListener::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterListener::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterListener_descriptor_;
}

const RegisterListener& RegisterListener::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SensorService_2eproto();
  return *default_instance_;
}

RegisterListener* RegisterListener::default_instance_ = NULL;

RegisterListener* RegisterListener::New(::google::protobuf::Arena* arena) const {
  RegisterListener* n = new RegisterListener;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegisterListener::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RegisterListener*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(type_, maxreportlatencyus_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RegisterListener::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorService.RegisterListener)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SensorService.RegisterListener.RegisterType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SensorService::RegisterListener_RegisterType_IsValid(value)) {
            set_type(static_cast< ::SensorService::RegisterListener_RegisterType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_sensorHandle;
        break;
      }

      // required int32 sensorHandle = 2;
      case 2: {
        if (tag == 16) {
         parse_sensorHandle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sensorhandle_)));
          set_has_sensorhandle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_samplingPeriodUs;
        break;
      }

      // optional int32 samplingPeriodUs = 3;
      case 3: {
        if (tag == 24) {
         parse_samplingPeriodUs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &samplingperiodus_)));
          set_has_samplingperiodus();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_maxReportLatencyUs;
        break;
      }

      // optional int32 maxReportLatencyUs = 4;
      case 4: {
        if (tag == 32) {
         parse_maxReportLatencyUs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxreportlatencyus_)));
          set_has_maxreportlatencyus();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorService.RegisterListener)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorService.RegisterListener)
  return false;
#undef DO_
}

void RegisterListener::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorService.RegisterListener)
  // required .SensorService.RegisterListener.RegisterType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required int32 sensorHandle = 2;
  if (has_sensorhandle()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->sensorhandle(), output);
  }

  // optional int32 samplingPeriodUs = 3;
  if (has_samplingperiodus()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->samplingperiodus(), output);
  }

  // optional int32 maxReportLatencyUs = 4;
  if (has_maxreportlatencyus()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->maxreportlatencyus(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorService.RegisterListener)
}

::google::protobuf::uint8* RegisterListener::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorService.RegisterListener)
  // required .SensorService.RegisterListener.RegisterType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required int32 sensorHandle = 2;
  if (has_sensorhandle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->sensorhandle(), target);
  }

  // optional int32 samplingPeriodUs = 3;
  if (has_samplingperiodus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->samplingperiodus(), target);
  }

  // optional int32 maxReportLatencyUs = 4;
  if (has_maxreportlatencyus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->maxreportlatencyus(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorService.RegisterListener)
  return target;
}

int RegisterListener::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_type()) {
    // required .SensorService.RegisterListener.RegisterType type = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  if (has_sensorhandle()) {
    // required int32 sensorHandle = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->sensorhandle());
  }

  return total_size;
}
int RegisterListener::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .SensorService.RegisterListener.RegisterType type = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

    // required int32 sensorHandle = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->sensorhandle());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[2 / 32] & 12u) {
    // optional int32 samplingPeriodUs = 3;
    if (has_samplingperiodus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->samplingperiodus());
    }

    // optional int32 maxReportLatencyUs = 4;
    if (has_maxreportlatencyus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxreportlatencyus());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterListener::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RegisterListener* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RegisterListener>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegisterListener::MergeFrom(const RegisterListener& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_sensorhandle()) {
      set_sensorhandle(from.sensorhandle());
    }
    if (from.has_samplingperiodus()) {
      set_samplingperiodus(from.samplingperiodus());
    }
    if (from.has_maxreportlatencyus()) {
      set_maxreportlatencyus(from.maxreportlatencyus());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RegisterListener::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterListener::CopyFrom(const RegisterListener& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterListener::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RegisterListener::Swap(RegisterListener* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegisterListener::InternalSwap(RegisterListener* other) {
  std::swap(type_, other->type_);
  std::swap(sensorhandle_, other->sensorhandle_);
  std::swap(samplingperiodus_, other->samplingperiodus_);
  std::swap(maxreportlatencyus_, other->maxreportlatencyus_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RegisterListener::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterListener_descriptor_;
  metadata.reflection = RegisterListener_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterListener

// required .SensorService.RegisterListener.RegisterType type = 1;
bool RegisterListener::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RegisterListener::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void RegisterListener::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void RegisterListener::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::SensorService::RegisterListener_RegisterType RegisterListener::type() const {
  // @@protoc_insertion_point(field_get:SensorService.RegisterListener.type)
  return static_cast< ::SensorService::RegisterListener_RegisterType >(type_);
}
 void RegisterListener::set_type(::SensorService::RegisterListener_RegisterType value) {
  assert(::SensorService::RegisterListener_RegisterType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SensorService.RegisterListener.type)
}

// required int32 sensorHandle = 2;
bool RegisterListener::has_sensorhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RegisterListener::set_has_sensorhandle() {
  _has_bits_[0] |= 0x00000002u;
}
void RegisterListener::clear_has_sensorhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
void RegisterListener::clear_sensorhandle() {
  sensorhandle_ = 0;
  clear_has_sensorhandle();
}
 ::google::protobuf::int32 RegisterListener::sensorhandle() const {
  // @@protoc_insertion_point(field_get:SensorService.RegisterListener.sensorHandle)
  return sensorhandle_;
}
 void RegisterListener::set_sensorhandle(::google::protobuf::int32 value) {
  set_has_sensorhandle();
  sensorhandle_ = value;
  // @@protoc_insertion_point(field_set:SensorService.RegisterListener.sensorHandle)
}

// optional int32 samplingPeriodUs = 3;
bool RegisterListener::has_samplingperiodus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RegisterListener::set_has_samplingperiodus() {
  _has_bits_[0] |= 0x00000004u;
}
void RegisterListener::clear_has_samplingperiodus() {
  _has_bits_[0] &= ~0x00000004u;
}
void RegisterListener::clear_samplingperiodus() {
  samplingperiodus_ = 0;
  clear_has_samplingperiodus();
}
 ::google::protobuf::int32 RegisterListener::samplingperiodus() const {
  // @@protoc_insertion_point(field_get:SensorService.RegisterListener.samplingPeriodUs)
  return samplingperiodus_;
}
 void RegisterListener::set_samplingperiodus(::google::protobuf::int32 value) {
  set_has_samplingperiodus();
  samplingperiodus_ = value;
  // @@protoc_insertion_point(field_set:SensorService.RegisterListener.samplingPeriodUs)
}

// optional int32 maxReportLatencyUs = 4;
bool RegisterListener::has_maxreportlatencyus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RegisterListener::set_has_maxreportlatencyus() {
  _has_bits_[0] |= 0x00000008u;
}
void RegisterListener::clear_has_maxreportlatencyus() {
  _has_bits_[0] &= ~0x00000008u;
}
void RegisterListener::clear_maxreportlatencyus() {
  maxreportlatencyus_ = 0;
  clear_has_maxreportlatencyus();
}
 ::google::protobuf::int32 RegisterListener::maxreportlatencyus() const {
  // @@protoc_insertion_point(field_get:SensorService.RegisterListener.maxReportLatencyUs)
  return maxreportlatencyus_;
}
 void RegisterListener::set_maxreportlatencyus(::google::protobuf::int32 value) {
  set_has_maxreportlatencyus();
  maxreportlatencyus_ = value;
  // @@protoc_insertion_point(field_set:SensorService.RegisterListener.maxReportLatencyUs)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int UnregisterListener::kSensorHandleFieldNumber;
#endif  // !_MSC_VER

UnregisterListener::UnregisterListener()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorService.UnregisterListener)
}

void UnregisterListener::InitAsDefaultInstance() {
}

UnregisterListener::UnregisterListener(const UnregisterListener& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorService.UnregisterListener)
}

void UnregisterListener::SharedCtor() {
  _cached_size_ = 0;
  sensorhandle_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnregisterListener::~UnregisterListener() {
  // @@protoc_insertion_point(destructor:SensorService.UnregisterListener)
  SharedDtor();
}

void UnregisterListener::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UnregisterListener::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnregisterListener::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnregisterListener_descriptor_;
}

const UnregisterListener& UnregisterListener::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SensorService_2eproto();
  return *default_instance_;
}

UnregisterListener* UnregisterListener::default_instance_ = NULL;

UnregisterListener* UnregisterListener::New(::google::protobuf::Arena* arena) const {
  UnregisterListener* n = new UnregisterListener;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UnregisterListener::Clear() {
  sensorhandle_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool UnregisterListener::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorService.UnregisterListener)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 sensorHandle = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sensorhandle_)));
          set_has_sensorhandle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorService.UnregisterListener)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorService.UnregisterListener)
  return false;
#undef DO_
}

void UnregisterListener::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorService.UnregisterListener)
  // required int32 sensorHandle = 1;
  if (has_sensorhandle()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->sensorhandle(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorService.UnregisterListener)
}

::google::protobuf::uint8* UnregisterListener::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorService.UnregisterListener)
  // required int32 sensorHandle = 1;
  if (has_sensorhandle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->sensorhandle(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorService.UnregisterListener)
  return target;
}

int UnregisterListener::ByteSize() const {
  int total_size = 0;

  // required int32 sensorHandle = 1;
  if (has_sensorhandle()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->sensorhandle());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnregisterListener::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const UnregisterListener* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const UnregisterListener>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnregisterListener::MergeFrom(const UnregisterListener& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sensorhandle()) {
      set_sensorhandle(from.sensorhandle());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void UnregisterListener::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnregisterListener::CopyFrom(const UnregisterListener& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnregisterListener::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UnregisterListener::Swap(UnregisterListener* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UnregisterListener::InternalSwap(UnregisterListener* other) {
  std::swap(sensorhandle_, other->sensorhandle_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata UnregisterListener::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnregisterListener_descriptor_;
  metadata.reflection = UnregisterListener_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UnregisterListener

// required int32 sensorHandle = 1;
bool UnregisterListener::has_sensorhandle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void UnregisterListener::set_has_sensorhandle() {
  _has_bits_[0] |= 0x00000001u;
}
void UnregisterListener::clear_has_sensorhandle() {
  _has_bits_[0] &= ~0x00000001u;
}
void UnregisterListener::clear_sensorhandle() {
  sensorhandle_ = 0;
  clear_has_sensorhandle();
}
 ::google::protobuf::int32 UnregisterListener::sensorhandle() const {
  // @@protoc_insertion_point(field_get:SensorService.UnregisterListener.sensorHandle)
  return sensorhandle_;
}
 void UnregisterListener::set_sensorhandle(::google::protobuf::int32 value) {
  set_has_sensorhandle();
  sensorhandle_ = value;
  // @@protoc_insertion_point(field_set:SensorService.UnregisterListener.sensorHandle)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Sensor::kNameFieldNumber;
const int Sensor::kVendorFieldNumber;
const int Sensor::kVersionFieldNumber;
const int Sensor::kHandleFieldNumber;
const int Sensor::kTypeFieldNumber;
const int Sensor::kMaxRangeFieldNumber;
const int Sensor::kResolutionFieldNumber;
const int Sensor::kPowerFieldNumber;
const int Sensor::kMinDelayFieldNumber;
const int Sensor::kFifoReservedEventCountFieldNumber;
const int Sensor::kFifoMaxEventCountFieldNumber;
const int Sensor::kStringTypeFieldNumber;
const int Sensor::kRequiredPermissionFieldNumber;
const int Sensor::kMaxDelayFieldNumber;
const int Sensor::kFlagsFieldNumber;
#endif  // !_MSC_VER

Sensor::Sensor()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorService.Sensor)
}

void Sensor::InitAsDefaultInstance() {
}

Sensor::Sensor(const Sensor& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorService.Sensor)
}

void Sensor::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vendor_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_ = 0;
  handle_ = 0;
  type_ = 0;
  maxrange_ = 0;
  resolution_ = 0;
  power_ = 0;
  mindelay_ = 0;
  fiforeservedeventcount_ = 0u;
  fifomaxeventcount_ = 0u;
  stringtype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  requiredpermission_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  maxdelay_ = 0u;
  flags_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sensor::~Sensor() {
  // @@protoc_insertion_point(destructor:SensorService.Sensor)
  SharedDtor();
}

void Sensor::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vendor_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  stringtype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  requiredpermission_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Sensor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sensor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sensor_descriptor_;
}

const Sensor& Sensor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SensorService_2eproto();
  return *default_instance_;
}

Sensor* Sensor::default_instance_ = NULL;

Sensor* Sensor::New(::google::protobuf::Arena* arena) const {
  Sensor* n = new Sensor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Sensor::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Sensor*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(version_, power_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_vendor()) {
      vendor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[8 / 32] & 32512u) {
    ZR_(mindelay_, fiforeservedeventcount_);
    ZR_(fifomaxeventcount_, maxdelay_);
    if (has_stringtype()) {
      stringtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_requiredpermission()) {
      requiredpermission_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    flags_ = 0u;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Sensor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorService.Sensor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "SensorService.Sensor.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vendor;
        break;
      }

      // required string vendor = 2;
      case 2: {
        if (tag == 18) {
         parse_vendor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vendor()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->vendor().data(), this->vendor().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "SensorService.Sensor.vendor");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_version;
        break;
      }

      // required int32 version = 3;
      case 3: {
        if (tag == 24) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_handle;
        break;
      }

      // required int32 handle = 4;
      case 4: {
        if (tag == 32) {
         parse_handle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &handle_)));
          set_has_handle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_type;
        break;
      }

      // required int32 type = 5;
      case 5: {
        if (tag == 40) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_maxRange;
        break;
      }

      // required float maxRange = 6;
      case 6: {
        if (tag == 53) {
         parse_maxRange:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &maxrange_)));
          set_has_maxrange();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_resolution;
        break;
      }

      // required float resolution = 7;
      case 7: {
        if (tag == 61) {
         parse_resolution:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &resolution_)));
          set_has_resolution();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_power;
        break;
      }

      // required float power = 8;
      case 8: {
        if (tag == 69) {
         parse_power:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &power_)));
          set_has_power();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_minDelay;
        break;
      }

      // required int32 minDelay = 9;
      case 9: {
        if (tag == 72) {
         parse_minDelay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mindelay_)));
          set_has_mindelay();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_fifoReservedEventCount;
        break;
      }

      // required uint32 fifoReservedEventCount = 10;
      case 10: {
        if (tag == 80) {
         parse_fifoReservedEventCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fiforeservedeventcount_)));
          set_has_fiforeservedeventcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_fifoMaxEventCount;
        break;
      }

      // required uint32 fifoMaxEventCount = 11;
      case 11: {
        if (tag == 88) {
         parse_fifoMaxEventCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fifomaxeventcount_)));
          set_has_fifomaxeventcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_stringType;
        break;
      }

      // required string stringType = 12;
      case 12: {
        if (tag == 98) {
         parse_stringType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_stringtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->stringtype().data(), this->stringtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "SensorService.Sensor.stringType");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_requiredPermission;
        break;
      }

      // required string requiredPermission = 13;
      case 13: {
        if (tag == 106) {
         parse_requiredPermission:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_requiredpermission()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->requiredpermission().data(), this->requiredpermission().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "SensorService.Sensor.requiredPermission");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_maxDelay;
        break;
      }

      // required uint32 maxDelay = 14;
      case 14: {
        if (tag == 112) {
         parse_maxDelay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &maxdelay_)));
          set_has_maxdelay();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_flags;
        break;
      }

      // required uint32 flags = 15;
      case 15: {
        if (tag == 120) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorService.Sensor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorService.Sensor)
  return false;
#undef DO_
}

void Sensor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorService.Sensor)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "SensorService.Sensor.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required string vendor = 2;
  if (has_vendor()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vendor().data(), this->vendor().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "SensorService.Sensor.vendor");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->vendor(), output);
  }

  // required int32 version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->version(), output);
  }

  // required int32 handle = 4;
  if (has_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->handle(), output);
  }

  // required int32 type = 5;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->type(), output);
  }

  // required float maxRange = 6;
  if (has_maxrange()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->maxrange(), output);
  }

  // required float resolution = 7;
  if (has_resolution()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->resolution(), output);
  }

  // required float power = 8;
  if (has_power()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->power(), output);
  }

  // required int32 minDelay = 9;
  if (has_mindelay()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->mindelay(), output);
  }

  // required uint32 fifoReservedEventCount = 10;
  if (has_fiforeservedeventcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->fiforeservedeventcount(), output);
  }

  // required uint32 fifoMaxEventCount = 11;
  if (has_fifomaxeventcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->fifomaxeventcount(), output);
  }

  // required string stringType = 12;
  if (has_stringtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->stringtype().data(), this->stringtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "SensorService.Sensor.stringType");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->stringtype(), output);
  }

  // required string requiredPermission = 13;
  if (has_requiredpermission()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->requiredpermission().data(), this->requiredpermission().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "SensorService.Sensor.requiredPermission");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      13, this->requiredpermission(), output);
  }

  // required uint32 maxDelay = 14;
  if (has_maxdelay()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->maxdelay(), output);
  }

  // required uint32 flags = 15;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->flags(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorService.Sensor)
}

::google::protobuf::uint8* Sensor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorService.Sensor)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "SensorService.Sensor.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required string vendor = 2;
  if (has_vendor()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vendor().data(), this->vendor().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "SensorService.Sensor.vendor");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->vendor(), target);
  }

  // required int32 version = 3;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->version(), target);
  }

  // required int32 handle = 4;
  if (has_handle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->handle(), target);
  }

  // required int32 type = 5;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->type(), target);
  }

  // required float maxRange = 6;
  if (has_maxrange()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->maxrange(), target);
  }

  // required float resolution = 7;
  if (has_resolution()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->resolution(), target);
  }

  // required float power = 8;
  if (has_power()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->power(), target);
  }

  // required int32 minDelay = 9;
  if (has_mindelay()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->mindelay(), target);
  }

  // required uint32 fifoReservedEventCount = 10;
  if (has_fiforeservedeventcount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->fiforeservedeventcount(), target);
  }

  // required uint32 fifoMaxEventCount = 11;
  if (has_fifomaxeventcount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->fifomaxeventcount(), target);
  }

  // required string stringType = 12;
  if (has_stringtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->stringtype().data(), this->stringtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "SensorService.Sensor.stringType");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->stringtype(), target);
  }

  // required string requiredPermission = 13;
  if (has_requiredpermission()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->requiredpermission().data(), this->requiredpermission().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "SensorService.Sensor.requiredPermission");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->requiredpermission(), target);
  }

  // required uint32 maxDelay = 14;
  if (has_maxdelay()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->maxdelay(), target);
  }

  // required uint32 flags = 15;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->flags(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorService.Sensor)
  return target;
}

int Sensor::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_vendor()) {
    // required string vendor = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vendor());
  }

  if (has_version()) {
    // required int32 version = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->version());
  }

  if (has_handle()) {
    // required int32 handle = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->handle());
  }

  if (has_type()) {
    // required int32 type = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->type());
  }

  if (has_maxrange()) {
    // required float maxRange = 6;
    total_size += 1 + 4;
  }

  if (has_resolution()) {
    // required float resolution = 7;
    total_size += 1 + 4;
  }

  if (has_power()) {
    // required float power = 8;
    total_size += 1 + 4;
  }

  if (has_mindelay()) {
    // required int32 minDelay = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->mindelay());
  }

  if (has_fiforeservedeventcount()) {
    // required uint32 fifoReservedEventCount = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->fiforeservedeventcount());
  }

  if (has_fifomaxeventcount()) {
    // required uint32 fifoMaxEventCount = 11;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->fifomaxeventcount());
  }

  if (has_stringtype()) {
    // required string stringType = 12;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->stringtype());
  }

  if (has_requiredpermission()) {
    // required string requiredPermission = 13;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->requiredpermission());
  }

  if (has_maxdelay()) {
    // required uint32 maxDelay = 14;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->maxdelay());
  }

  if (has_flags()) {
    // required uint32 flags = 15;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->flags());
  }

  return total_size;
}
int Sensor::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00007fff) ^ 0x00007fff) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required string vendor = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vendor());

    // required int32 version = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->version());

    // required int32 handle = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->handle());

    // required int32 type = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->type());

    // required float maxRange = 6;
    total_size += 1 + 4;

    // required float resolution = 7;
    total_size += 1 + 4;

    // required float power = 8;
    total_size += 1 + 4;

    // required int32 minDelay = 9;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->mindelay());

    // required uint32 fifoReservedEventCount = 10;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->fiforeservedeventcount());

    // required uint32 fifoMaxEventCount = 11;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->fifomaxeventcount());

    // required string stringType = 12;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->stringtype());

    // required string requiredPermission = 13;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->requiredpermission());

    // required uint32 maxDelay = 14;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->maxdelay());

    // required uint32 flags = 15;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->flags());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sensor::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Sensor* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Sensor>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Sensor::MergeFrom(const Sensor& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_vendor()) {
      set_has_vendor();
      vendor_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vendor_);
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_handle()) {
      set_handle(from.handle());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_maxrange()) {
      set_maxrange(from.maxrange());
    }
    if (from.has_resolution()) {
      set_resolution(from.resolution());
    }
    if (from.has_power()) {
      set_power(from.power());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_mindelay()) {
      set_mindelay(from.mindelay());
    }
    if (from.has_fiforeservedeventcount()) {
      set_fiforeservedeventcount(from.fiforeservedeventcount());
    }
    if (from.has_fifomaxeventcount()) {
      set_fifomaxeventcount(from.fifomaxeventcount());
    }
    if (from.has_stringtype()) {
      set_has_stringtype();
      stringtype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.stringtype_);
    }
    if (from.has_requiredpermission()) {
      set_has_requiredpermission();
      requiredpermission_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.requiredpermission_);
    }
    if (from.has_maxdelay()) {
      set_maxdelay(from.maxdelay());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Sensor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sensor::CopyFrom(const Sensor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sensor::IsInitialized() const {
  if ((_has_bits_[0] & 0x00007fff) != 0x00007fff) return false;

  return true;
}

void Sensor::Swap(Sensor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Sensor::InternalSwap(Sensor* other) {
  name_.Swap(&other->name_);
  vendor_.Swap(&other->vendor_);
  std::swap(version_, other->version_);
  std::swap(handle_, other->handle_);
  std::swap(type_, other->type_);
  std::swap(maxrange_, other->maxrange_);
  std::swap(resolution_, other->resolution_);
  std::swap(power_, other->power_);
  std::swap(mindelay_, other->mindelay_);
  std::swap(fiforeservedeventcount_, other->fiforeservedeventcount_);
  std::swap(fifomaxeventcount_, other->fifomaxeventcount_);
  stringtype_.Swap(&other->stringtype_);
  requiredpermission_.Swap(&other->requiredpermission_);
  std::swap(maxdelay_, other->maxdelay_);
  std::swap(flags_, other->flags_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Sensor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sensor_descriptor_;
  metadata.reflection = Sensor_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Sensor

// required string name = 1;
bool Sensor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Sensor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Sensor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Sensor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Sensor::name() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sensor::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SensorService.Sensor.name)
}
 void Sensor::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SensorService.Sensor.name)
}
 void Sensor::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SensorService.Sensor.name)
}
 ::std::string* Sensor::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:SensorService.Sensor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Sensor::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sensor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SensorService.Sensor.name)
}

// required string vendor = 2;
bool Sensor::has_vendor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Sensor::set_has_vendor() {
  _has_bits_[0] |= 0x00000002u;
}
void Sensor::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000002u;
}
void Sensor::clear_vendor() {
  vendor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vendor();
}
 const ::std::string& Sensor::vendor() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.vendor)
  return vendor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sensor::set_vendor(const ::std::string& value) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SensorService.Sensor.vendor)
}
 void Sensor::set_vendor(const char* value) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SensorService.Sensor.vendor)
}
 void Sensor::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SensorService.Sensor.vendor)
}
 ::std::string* Sensor::mutable_vendor() {
  set_has_vendor();
  // @@protoc_insertion_point(field_mutable:SensorService.Sensor.vendor)
  return vendor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Sensor::release_vendor() {
  clear_has_vendor();
  return vendor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sensor::set_allocated_vendor(::std::string* vendor) {
  if (vendor != NULL) {
    set_has_vendor();
  } else {
    clear_has_vendor();
  }
  vendor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vendor);
  // @@protoc_insertion_point(field_set_allocated:SensorService.Sensor.vendor)
}

// required int32 version = 3;
bool Sensor::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Sensor::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
void Sensor::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
void Sensor::clear_version() {
  version_ = 0;
  clear_has_version();
}
 ::google::protobuf::int32 Sensor::version() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.version)
  return version_;
}
 void Sensor::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.version)
}

// required int32 handle = 4;
bool Sensor::has_handle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Sensor::set_has_handle() {
  _has_bits_[0] |= 0x00000008u;
}
void Sensor::clear_has_handle() {
  _has_bits_[0] &= ~0x00000008u;
}
void Sensor::clear_handle() {
  handle_ = 0;
  clear_has_handle();
}
 ::google::protobuf::int32 Sensor::handle() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.handle)
  return handle_;
}
 void Sensor::set_handle(::google::protobuf::int32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.handle)
}

// required int32 type = 5;
bool Sensor::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Sensor::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
void Sensor::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
void Sensor::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::google::protobuf::int32 Sensor::type() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.type)
  return type_;
}
 void Sensor::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.type)
}

// required float maxRange = 6;
bool Sensor::has_maxrange() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Sensor::set_has_maxrange() {
  _has_bits_[0] |= 0x00000020u;
}
void Sensor::clear_has_maxrange() {
  _has_bits_[0] &= ~0x00000020u;
}
void Sensor::clear_maxrange() {
  maxrange_ = 0;
  clear_has_maxrange();
}
 float Sensor::maxrange() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.maxRange)
  return maxrange_;
}
 void Sensor::set_maxrange(float value) {
  set_has_maxrange();
  maxrange_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.maxRange)
}

// required float resolution = 7;
bool Sensor::has_resolution() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Sensor::set_has_resolution() {
  _has_bits_[0] |= 0x00000040u;
}
void Sensor::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000040u;
}
void Sensor::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
 float Sensor::resolution() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.resolution)
  return resolution_;
}
 void Sensor::set_resolution(float value) {
  set_has_resolution();
  resolution_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.resolution)
}

// required float power = 8;
bool Sensor::has_power() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Sensor::set_has_power() {
  _has_bits_[0] |= 0x00000080u;
}
void Sensor::clear_has_power() {
  _has_bits_[0] &= ~0x00000080u;
}
void Sensor::clear_power() {
  power_ = 0;
  clear_has_power();
}
 float Sensor::power() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.power)
  return power_;
}
 void Sensor::set_power(float value) {
  set_has_power();
  power_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.power)
}

// required int32 minDelay = 9;
bool Sensor::has_mindelay() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Sensor::set_has_mindelay() {
  _has_bits_[0] |= 0x00000100u;
}
void Sensor::clear_has_mindelay() {
  _has_bits_[0] &= ~0x00000100u;
}
void Sensor::clear_mindelay() {
  mindelay_ = 0;
  clear_has_mindelay();
}
 ::google::protobuf::int32 Sensor::mindelay() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.minDelay)
  return mindelay_;
}
 void Sensor::set_mindelay(::google::protobuf::int32 value) {
  set_has_mindelay();
  mindelay_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.minDelay)
}

// required uint32 fifoReservedEventCount = 10;
bool Sensor::has_fiforeservedeventcount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Sensor::set_has_fiforeservedeventcount() {
  _has_bits_[0] |= 0x00000200u;
}
void Sensor::clear_has_fiforeservedeventcount() {
  _has_bits_[0] &= ~0x00000200u;
}
void Sensor::clear_fiforeservedeventcount() {
  fiforeservedeventcount_ = 0u;
  clear_has_fiforeservedeventcount();
}
 ::google::protobuf::uint32 Sensor::fiforeservedeventcount() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.fifoReservedEventCount)
  return fiforeservedeventcount_;
}
 void Sensor::set_fiforeservedeventcount(::google::protobuf::uint32 value) {
  set_has_fiforeservedeventcount();
  fiforeservedeventcount_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.fifoReservedEventCount)
}

// required uint32 fifoMaxEventCount = 11;
bool Sensor::has_fifomaxeventcount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void Sensor::set_has_fifomaxeventcount() {
  _has_bits_[0] |= 0x00000400u;
}
void Sensor::clear_has_fifomaxeventcount() {
  _has_bits_[0] &= ~0x00000400u;
}
void Sensor::clear_fifomaxeventcount() {
  fifomaxeventcount_ = 0u;
  clear_has_fifomaxeventcount();
}
 ::google::protobuf::uint32 Sensor::fifomaxeventcount() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.fifoMaxEventCount)
  return fifomaxeventcount_;
}
 void Sensor::set_fifomaxeventcount(::google::protobuf::uint32 value) {
  set_has_fifomaxeventcount();
  fifomaxeventcount_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.fifoMaxEventCount)
}

// required string stringType = 12;
bool Sensor::has_stringtype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void Sensor::set_has_stringtype() {
  _has_bits_[0] |= 0x00000800u;
}
void Sensor::clear_has_stringtype() {
  _has_bits_[0] &= ~0x00000800u;
}
void Sensor::clear_stringtype() {
  stringtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_stringtype();
}
 const ::std::string& Sensor::stringtype() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.stringType)
  return stringtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sensor::set_stringtype(const ::std::string& value) {
  set_has_stringtype();
  stringtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SensorService.Sensor.stringType)
}
 void Sensor::set_stringtype(const char* value) {
  set_has_stringtype();
  stringtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SensorService.Sensor.stringType)
}
 void Sensor::set_stringtype(const char* value, size_t size) {
  set_has_stringtype();
  stringtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SensorService.Sensor.stringType)
}
 ::std::string* Sensor::mutable_stringtype() {
  set_has_stringtype();
  // @@protoc_insertion_point(field_mutable:SensorService.Sensor.stringType)
  return stringtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Sensor::release_stringtype() {
  clear_has_stringtype();
  return stringtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sensor::set_allocated_stringtype(::std::string* stringtype) {
  if (stringtype != NULL) {
    set_has_stringtype();
  } else {
    clear_has_stringtype();
  }
  stringtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stringtype);
  // @@protoc_insertion_point(field_set_allocated:SensorService.Sensor.stringType)
}

// required string requiredPermission = 13;
bool Sensor::has_requiredpermission() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void Sensor::set_has_requiredpermission() {
  _has_bits_[0] |= 0x00001000u;
}
void Sensor::clear_has_requiredpermission() {
  _has_bits_[0] &= ~0x00001000u;
}
void Sensor::clear_requiredpermission() {
  requiredpermission_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_requiredpermission();
}
 const ::std::string& Sensor::requiredpermission() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.requiredPermission)
  return requiredpermission_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sensor::set_requiredpermission(const ::std::string& value) {
  set_has_requiredpermission();
  requiredpermission_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SensorService.Sensor.requiredPermission)
}
 void Sensor::set_requiredpermission(const char* value) {
  set_has_requiredpermission();
  requiredpermission_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SensorService.Sensor.requiredPermission)
}
 void Sensor::set_requiredpermission(const char* value, size_t size) {
  set_has_requiredpermission();
  requiredpermission_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SensorService.Sensor.requiredPermission)
}
 ::std::string* Sensor::mutable_requiredpermission() {
  set_has_requiredpermission();
  // @@protoc_insertion_point(field_mutable:SensorService.Sensor.requiredPermission)
  return requiredpermission_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Sensor::release_requiredpermission() {
  clear_has_requiredpermission();
  return requiredpermission_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sensor::set_allocated_requiredpermission(::std::string* requiredpermission) {
  if (requiredpermission != NULL) {
    set_has_requiredpermission();
  } else {
    clear_has_requiredpermission();
  }
  requiredpermission_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requiredpermission);
  // @@protoc_insertion_point(field_set_allocated:SensorService.Sensor.requiredPermission)
}

// required uint32 maxDelay = 14;
bool Sensor::has_maxdelay() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void Sensor::set_has_maxdelay() {
  _has_bits_[0] |= 0x00002000u;
}
void Sensor::clear_has_maxdelay() {
  _has_bits_[0] &= ~0x00002000u;
}
void Sensor::clear_maxdelay() {
  maxdelay_ = 0u;
  clear_has_maxdelay();
}
 ::google::protobuf::uint32 Sensor::maxdelay() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.maxDelay)
  return maxdelay_;
}
 void Sensor::set_maxdelay(::google::protobuf::uint32 value) {
  set_has_maxdelay();
  maxdelay_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.maxDelay)
}

// required uint32 flags = 15;
bool Sensor::has_flags() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void Sensor::set_has_flags() {
  _has_bits_[0] |= 0x00004000u;
}
void Sensor::clear_has_flags() {
  _has_bits_[0] &= ~0x00004000u;
}
void Sensor::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
 ::google::protobuf::uint32 Sensor::flags() const {
  // @@protoc_insertion_point(field_get:SensorService.Sensor.flags)
  return flags_;
}
 void Sensor::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Sensor.flags)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int SensorDataEvent::kAccuracyFieldNumber;
const int SensorDataEvent::kSensorHandleFieldNumber;
const int SensorDataEvent::kTimestampFieldNumber;
const int SensorDataEvent::kXvalueFieldNumber;
const int SensorDataEvent::kYvalueFieldNumber;
const int SensorDataEvent::kZvalueFieldNumber;
#endif  // !_MSC_VER

SensorDataEvent::SensorDataEvent()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorService.SensorDataEvent)
}

void SensorDataEvent::InitAsDefaultInstance() {
}

SensorDataEvent::SensorDataEvent(const SensorDataEvent& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorService.SensorDataEvent)
}

void SensorDataEvent::SharedCtor() {
  _cached_size_ = 0;
  accuracy_ = 0;
  sensorhandle_ = 0;
  timestamp_ = GOOGLE_LONGLONG(0);
  xvalue_ = 0;
  yvalue_ = 0;
  zvalue_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SensorDataEvent::~SensorDataEvent() {
  // @@protoc_insertion_point(destructor:SensorService.SensorDataEvent)
  SharedDtor();
}

void SensorDataEvent::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SensorDataEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SensorDataEvent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SensorDataEvent_descriptor_;
}

const SensorDataEvent& SensorDataEvent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SensorService_2eproto();
  return *default_instance_;
}

SensorDataEvent* SensorDataEvent::default_instance_ = NULL;

SensorDataEvent* SensorDataEvent::New(::google::protobuf::Arena* arena) const {
  SensorDataEvent* n = new SensorDataEvent;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SensorDataEvent::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SensorDataEvent*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(accuracy_, zvalue_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SensorDataEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorService.SensorDataEvent)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 accuracy = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &accuracy_)));
          set_has_accuracy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_sensorHandle;
        break;
      }

      // required int32 sensorHandle = 2;
      case 2: {
        if (tag == 16) {
         parse_sensorHandle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sensorhandle_)));
          set_has_sensorhandle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_timestamp;
        break;
      }

      // required int64 timestamp = 3;
      case 3: {
        if (tag == 24) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_xvalue;
        break;
      }

      // required float xvalue = 4;
      case 4: {
        if (tag == 37) {
         parse_xvalue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &xvalue_)));
          set_has_xvalue();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_yvalue;
        break;
      }

      // optional float yvalue = 5;
      case 5: {
        if (tag == 45) {
         parse_yvalue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yvalue_)));
          set_has_yvalue();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_zvalue;
        break;
      }

      // optional float zvalue = 6;
      case 6: {
        if (tag == 53) {
         parse_zvalue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &zvalue_)));
          set_has_zvalue();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorService.SensorDataEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorService.SensorDataEvent)
  return false;
#undef DO_
}

void SensorDataEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorService.SensorDataEvent)
  // required int32 accuracy = 1;
  if (has_accuracy()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->accuracy(), output);
  }

  // required int32 sensorHandle = 2;
  if (has_sensorhandle()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->sensorhandle(), output);
  }

  // required int64 timestamp = 3;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->timestamp(), output);
  }

  // required float xvalue = 4;
  if (has_xvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->xvalue(), output);
  }

  // optional float yvalue = 5;
  if (has_yvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->yvalue(), output);
  }

  // optional float zvalue = 6;
  if (has_zvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->zvalue(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorService.SensorDataEvent)
}

::google::protobuf::uint8* SensorDataEvent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorService.SensorDataEvent)
  // required int32 accuracy = 1;
  if (has_accuracy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->accuracy(), target);
  }

  // required int32 sensorHandle = 2;
  if (has_sensorhandle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->sensorhandle(), target);
  }

  // required int64 timestamp = 3;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->timestamp(), target);
  }

  // required float xvalue = 4;
  if (has_xvalue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->xvalue(), target);
  }

  // optional float yvalue = 5;
  if (has_yvalue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->yvalue(), target);
  }

  // optional float zvalue = 6;
  if (has_zvalue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->zvalue(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorService.SensorDataEvent)
  return target;
}

int SensorDataEvent::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_accuracy()) {
    // required int32 accuracy = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->accuracy());
  }

  if (has_sensorhandle()) {
    // required int32 sensorHandle = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->sensorhandle());
  }

  if (has_timestamp()) {
    // required int64 timestamp = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->timestamp());
  }

  if (has_xvalue()) {
    // required float xvalue = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
int SensorDataEvent::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 accuracy = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->accuracy());

    // required int32 sensorHandle = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->sensorhandle());

    // required int64 timestamp = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->timestamp());

    // required float xvalue = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[4 / 32] & 48u) {
    // optional float yvalue = 5;
    if (has_yvalue()) {
      total_size += 1 + 4;
    }

    // optional float zvalue = 6;
    if (has_zvalue()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SensorDataEvent::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const SensorDataEvent* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SensorDataEvent>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SensorDataEvent::MergeFrom(const SensorDataEvent& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accuracy()) {
      set_accuracy(from.accuracy());
    }
    if (from.has_sensorhandle()) {
      set_sensorhandle(from.sensorhandle());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_xvalue()) {
      set_xvalue(from.xvalue());
    }
    if (from.has_yvalue()) {
      set_yvalue(from.yvalue());
    }
    if (from.has_zvalue()) {
      set_zvalue(from.zvalue());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SensorDataEvent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorDataEvent::CopyFrom(const SensorDataEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorDataEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void SensorDataEvent::Swap(SensorDataEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SensorDataEvent::InternalSwap(SensorDataEvent* other) {
  std::swap(accuracy_, other->accuracy_);
  std::swap(sensorhandle_, other->sensorhandle_);
  std::swap(timestamp_, other->timestamp_);
  std::swap(xvalue_, other->xvalue_);
  std::swap(yvalue_, other->yvalue_);
  std::swap(zvalue_, other->zvalue_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SensorDataEvent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SensorDataEvent_descriptor_;
  metadata.reflection = SensorDataEvent_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SensorDataEvent

// required int32 accuracy = 1;
bool SensorDataEvent::has_accuracy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SensorDataEvent::set_has_accuracy() {
  _has_bits_[0] |= 0x00000001u;
}
void SensorDataEvent::clear_has_accuracy() {
  _has_bits_[0] &= ~0x00000001u;
}
void SensorDataEvent::clear_accuracy() {
  accuracy_ = 0;
  clear_has_accuracy();
}
 ::google::protobuf::int32 SensorDataEvent::accuracy() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.accuracy)
  return accuracy_;
}
 void SensorDataEvent::set_accuracy(::google::protobuf::int32 value) {
  set_has_accuracy();
  accuracy_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.accuracy)
}

// required int32 sensorHandle = 2;
bool SensorDataEvent::has_sensorhandle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SensorDataEvent::set_has_sensorhandle() {
  _has_bits_[0] |= 0x00000002u;
}
void SensorDataEvent::clear_has_sensorhandle() {
  _has_bits_[0] &= ~0x00000002u;
}
void SensorDataEvent::clear_sensorhandle() {
  sensorhandle_ = 0;
  clear_has_sensorhandle();
}
 ::google::protobuf::int32 SensorDataEvent::sensorhandle() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.sensorHandle)
  return sensorhandle_;
}
 void SensorDataEvent::set_sensorhandle(::google::protobuf::int32 value) {
  set_has_sensorhandle();
  sensorhandle_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.sensorHandle)
}

// required int64 timestamp = 3;
bool SensorDataEvent::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SensorDataEvent::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
void SensorDataEvent::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
void SensorDataEvent::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
 ::google::protobuf::int64 SensorDataEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.timestamp)
  return timestamp_;
}
 void SensorDataEvent::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.timestamp)
}

// required float xvalue = 4;
bool SensorDataEvent::has_xvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SensorDataEvent::set_has_xvalue() {
  _has_bits_[0] |= 0x00000008u;
}
void SensorDataEvent::clear_has_xvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
void SensorDataEvent::clear_xvalue() {
  xvalue_ = 0;
  clear_has_xvalue();
}
 float SensorDataEvent::xvalue() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.xvalue)
  return xvalue_;
}
 void SensorDataEvent::set_xvalue(float value) {
  set_has_xvalue();
  xvalue_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.xvalue)
}

// optional float yvalue = 5;
bool SensorDataEvent::has_yvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void SensorDataEvent::set_has_yvalue() {
  _has_bits_[0] |= 0x00000010u;
}
void SensorDataEvent::clear_has_yvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
void SensorDataEvent::clear_yvalue() {
  yvalue_ = 0;
  clear_has_yvalue();
}
 float SensorDataEvent::yvalue() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.yvalue)
  return yvalue_;
}
 void SensorDataEvent::set_yvalue(float value) {
  set_has_yvalue();
  yvalue_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.yvalue)
}

// optional float zvalue = 6;
bool SensorDataEvent::has_zvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void SensorDataEvent::set_has_zvalue() {
  _has_bits_[0] |= 0x00000020u;
}
void SensorDataEvent::clear_has_zvalue() {
  _has_bits_[0] &= ~0x00000020u;
}
void SensorDataEvent::clear_zvalue() {
  zvalue_ = 0;
  clear_has_zvalue();
}
 float SensorDataEvent::zvalue() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorDataEvent.zvalue)
  return zvalue_;
}
 void SensorDataEvent::set_zvalue(float value) {
  set_has_zvalue();
  zvalue_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorDataEvent.zvalue)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int SensorAccuracyEvent::kSensorHandleFieldNumber;
const int SensorAccuracyEvent::kAccuracyFieldNumber;
#endif  // !_MSC_VER

SensorAccuracyEvent::SensorAccuracyEvent()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorService.SensorAccuracyEvent)
}

void SensorAccuracyEvent::InitAsDefaultInstance() {
}

SensorAccuracyEvent::SensorAccuracyEvent(const SensorAccuracyEvent& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorService.SensorAccuracyEvent)
}

void SensorAccuracyEvent::SharedCtor() {
  _cached_size_ = 0;
  sensorhandle_ = 0;
  accuracy_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SensorAccuracyEvent::~SensorAccuracyEvent() {
  // @@protoc_insertion_point(destructor:SensorService.SensorAccuracyEvent)
  SharedDtor();
}

void SensorAccuracyEvent::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SensorAccuracyEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SensorAccuracyEvent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SensorAccuracyEvent_descriptor_;
}

const SensorAccuracyEvent& SensorAccuracyEvent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SensorService_2eproto();
  return *default_instance_;
}

SensorAccuracyEvent* SensorAccuracyEvent::default_instance_ = NULL;

SensorAccuracyEvent* SensorAccuracyEvent::New(::google::protobuf::Arena* arena) const {
  SensorAccuracyEvent* n = new SensorAccuracyEvent;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SensorAccuracyEvent::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SensorAccuracyEvent*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(sensorhandle_, accuracy_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SensorAccuracyEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorService.SensorAccuracyEvent)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 sensorHandle = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sensorhandle_)));
          set_has_sensorhandle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_accuracy;
        break;
      }

      // required int32 accuracy = 2;
      case 2: {
        if (tag == 16) {
         parse_accuracy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &accuracy_)));
          set_has_accuracy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorService.SensorAccuracyEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorService.SensorAccuracyEvent)
  return false;
#undef DO_
}

void SensorAccuracyEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorService.SensorAccuracyEvent)
  // required int32 sensorHandle = 1;
  if (has_sensorhandle()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->sensorhandle(), output);
  }

  // required int32 accuracy = 2;
  if (has_accuracy()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->accuracy(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorService.SensorAccuracyEvent)
}

::google::protobuf::uint8* SensorAccuracyEvent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorService.SensorAccuracyEvent)
  // required int32 sensorHandle = 1;
  if (has_sensorhandle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->sensorhandle(), target);
  }

  // required int32 accuracy = 2;
  if (has_accuracy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->accuracy(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorService.SensorAccuracyEvent)
  return target;
}

int SensorAccuracyEvent::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_sensorhandle()) {
    // required int32 sensorHandle = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->sensorhandle());
  }

  if (has_accuracy()) {
    // required int32 accuracy = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->accuracy());
  }

  return total_size;
}
int SensorAccuracyEvent::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 sensorHandle = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->sensorhandle());

    // required int32 accuracy = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->accuracy());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SensorAccuracyEvent::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const SensorAccuracyEvent* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SensorAccuracyEvent>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SensorAccuracyEvent::MergeFrom(const SensorAccuracyEvent& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sensorhandle()) {
      set_sensorhandle(from.sensorhandle());
    }
    if (from.has_accuracy()) {
      set_accuracy(from.accuracy());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SensorAccuracyEvent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorAccuracyEvent::CopyFrom(const SensorAccuracyEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorAccuracyEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SensorAccuracyEvent::Swap(SensorAccuracyEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SensorAccuracyEvent::InternalSwap(SensorAccuracyEvent* other) {
  std::swap(sensorhandle_, other->sensorhandle_);
  std::swap(accuracy_, other->accuracy_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SensorAccuracyEvent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SensorAccuracyEvent_descriptor_;
  metadata.reflection = SensorAccuracyEvent_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SensorAccuracyEvent

// required int32 sensorHandle = 1;
bool SensorAccuracyEvent::has_sensorhandle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SensorAccuracyEvent::set_has_sensorhandle() {
  _has_bits_[0] |= 0x00000001u;
}
void SensorAccuracyEvent::clear_has_sensorhandle() {
  _has_bits_[0] &= ~0x00000001u;
}
void SensorAccuracyEvent::clear_sensorhandle() {
  sensorhandle_ = 0;
  clear_has_sensorhandle();
}
 ::google::protobuf::int32 SensorAccuracyEvent::sensorhandle() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorAccuracyEvent.sensorHandle)
  return sensorhandle_;
}
 void SensorAccuracyEvent::set_sensorhandle(::google::protobuf::int32 value) {
  set_has_sensorhandle();
  sensorhandle_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorAccuracyEvent.sensorHandle)
}

// required int32 accuracy = 2;
bool SensorAccuracyEvent::has_accuracy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SensorAccuracyEvent::set_has_accuracy() {
  _has_bits_[0] |= 0x00000002u;
}
void SensorAccuracyEvent::clear_has_accuracy() {
  _has_bits_[0] &= ~0x00000002u;
}
void SensorAccuracyEvent::clear_accuracy() {
  accuracy_ = 0;
  clear_has_accuracy();
}
 ::google::protobuf::int32 SensorAccuracyEvent::accuracy() const {
  // @@protoc_insertion_point(field_get:SensorService.SensorAccuracyEvent.accuracy)
  return accuracy_;
}
 void SensorAccuracyEvent::set_accuracy(::google::protobuf::int32 value) {
  set_has_accuracy();
  accuracy_ = value;
  // @@protoc_insertion_point(field_set:SensorService.SensorAccuracyEvent.accuracy)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Request_RequestType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Request_RequestType_descriptor_;
}
bool Request_RequestType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Request_RequestType Request::REGISTER;
const Request_RequestType Request::UNREGISTER;
const Request_RequestType Request::GET_SENSOR_LIST;
const Request_RequestType Request::RequestType_MIN;
const Request_RequestType Request::RequestType_MAX;
const int Request::RequestType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Request::kReqTypeFieldNumber;
const int Request::kRegListenerFieldNumber;
const int Request::kUnRegListenerFieldNumber;
#endif  // !_MSC_VER

Request::Request()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorService.Request)
}

void Request::InitAsDefaultInstance() {
  reglistener_ = const_cast< ::SensorService::RegisterListener*>(&::SensorService::RegisterListener::default_instance());
  unreglistener_ = const_cast< ::SensorService::UnregisterListener*>(&::SensorService::UnregisterListener::default_instance());
}

Request::Request(const Request& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorService.Request)
}

void Request::SharedCtor() {
  _cached_size_ = 0;
  reqtype_ = 0;
  reglistener_ = NULL;
  unreglistener_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:SensorService.Request)
  SharedDtor();
}

void Request::SharedDtor() {
  if (this != default_instance_) {
    delete reglistener_;
    delete unreglistener_;
  }
}

void Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Request::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Request_descriptor_;
}

const Request& Request::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SensorService_2eproto();
  return *default_instance_;
}

Request* Request::default_instance_ = NULL;

Request* Request::New(::google::protobuf::Arena* arena) const {
  Request* n = new Request;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Request::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    reqtype_ = 0;
    if (has_reglistener()) {
      if (reglistener_ != NULL) reglistener_->::SensorService::RegisterListener::Clear();
    }
    if (has_unreglistener()) {
      if (unreglistener_ != NULL) unreglistener_->::SensorService::UnregisterListener::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorService.Request)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SensorService.Request.RequestType reqType = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SensorService::Request_RequestType_IsValid(value)) {
            set_reqtype(static_cast< ::SensorService::Request_RequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_regListener;
        break;
      }

      // optional .SensorService.RegisterListener regListener = 2;
      case 2: {
        if (tag == 18) {
         parse_regListener:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reglistener()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_unRegListener;
        break;
      }

      // optional .SensorService.UnregisterListener unRegListener = 3;
      case 3: {
        if (tag == 26) {
         parse_unRegListener:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unreglistener()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorService.Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorService.Request)
  return false;
#undef DO_
}

void Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorService.Request)
  // required .SensorService.Request.RequestType reqType = 1;
  if (has_reqtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->reqtype(), output);
  }

  // optional .SensorService.RegisterListener regListener = 2;
  if (has_reglistener()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->reglistener_, output);
  }

  // optional .SensorService.UnregisterListener unRegListener = 3;
  if (has_unreglistener()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->unreglistener_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorService.Request)
}

::google::protobuf::uint8* Request::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorService.Request)
  // required .SensorService.Request.RequestType reqType = 1;
  if (has_reqtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->reqtype(), target);
  }

  // optional .SensorService.RegisterListener regListener = 2;
  if (has_reglistener()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->reglistener_, target);
  }

  // optional .SensorService.UnregisterListener unRegListener = 3;
  if (has_unreglistener()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->unreglistener_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorService.Request)
  return target;
}

int Request::ByteSize() const {
  int total_size = 0;

  // required .SensorService.Request.RequestType reqType = 1;
  if (has_reqtype()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->reqtype());
  }
  if (_has_bits_[1 / 32] & 6u) {
    // optional .SensorService.RegisterListener regListener = 2;
    if (has_reglistener()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->reglistener_);
    }

    // optional .SensorService.UnregisterListener unRegListener = 3;
    if (has_unreglistener()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->unreglistener_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Request::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Request* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Request>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Request::MergeFrom(const Request& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reqtype()) {
      set_reqtype(from.reqtype());
    }
    if (from.has_reglistener()) {
      mutable_reglistener()->::SensorService::RegisterListener::MergeFrom(from.reglistener());
    }
    if (from.has_unreglistener()) {
      mutable_unreglistener()->::SensorService::UnregisterListener::MergeFrom(from.unreglistener());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Request::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Request::CopyFrom(const Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_reglistener()) {
    if (!this->reglistener_->IsInitialized()) return false;
  }
  if (has_unreglistener()) {
    if (!this->unreglistener_->IsInitialized()) return false;
  }
  return true;
}

void Request::Swap(Request* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Request::InternalSwap(Request* other) {
  std::swap(reqtype_, other->reqtype_);
  std::swap(reglistener_, other->reglistener_);
  std::swap(unreglistener_, other->unreglistener_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Request::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Request_descriptor_;
  metadata.reflection = Request_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Request

// required .SensorService.Request.RequestType reqType = 1;
bool Request::has_reqtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Request::set_has_reqtype() {
  _has_bits_[0] |= 0x00000001u;
}
void Request::clear_has_reqtype() {
  _has_bits_[0] &= ~0x00000001u;
}
void Request::clear_reqtype() {
  reqtype_ = 0;
  clear_has_reqtype();
}
 ::SensorService::Request_RequestType Request::reqtype() const {
  // @@protoc_insertion_point(field_get:SensorService.Request.reqType)
  return static_cast< ::SensorService::Request_RequestType >(reqtype_);
}
 void Request::set_reqtype(::SensorService::Request_RequestType value) {
  assert(::SensorService::Request_RequestType_IsValid(value));
  set_has_reqtype();
  reqtype_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Request.reqType)
}

// optional .SensorService.RegisterListener regListener = 2;
bool Request::has_reglistener() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Request::set_has_reglistener() {
  _has_bits_[0] |= 0x00000002u;
}
void Request::clear_has_reglistener() {
  _has_bits_[0] &= ~0x00000002u;
}
void Request::clear_reglistener() {
  if (reglistener_ != NULL) reglistener_->::SensorService::RegisterListener::Clear();
  clear_has_reglistener();
}
const ::SensorService::RegisterListener& Request::reglistener() const {
  // @@protoc_insertion_point(field_get:SensorService.Request.regListener)
  return reglistener_ != NULL ? *reglistener_ : *default_instance_->reglistener_;
}
::SensorService::RegisterListener* Request::mutable_reglistener() {
  set_has_reglistener();
  if (reglistener_ == NULL) {
    reglistener_ = new ::SensorService::RegisterListener;
  }
  // @@protoc_insertion_point(field_mutable:SensorService.Request.regListener)
  return reglistener_;
}
::SensorService::RegisterListener* Request::release_reglistener() {
  clear_has_reglistener();
  ::SensorService::RegisterListener* temp = reglistener_;
  reglistener_ = NULL;
  return temp;
}
void Request::set_allocated_reglistener(::SensorService::RegisterListener* reglistener) {
  delete reglistener_;
  reglistener_ = reglistener;
  if (reglistener) {
    set_has_reglistener();
  } else {
    clear_has_reglistener();
  }
  // @@protoc_insertion_point(field_set_allocated:SensorService.Request.regListener)
}

// optional .SensorService.UnregisterListener unRegListener = 3;
bool Request::has_unreglistener() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Request::set_has_unreglistener() {
  _has_bits_[0] |= 0x00000004u;
}
void Request::clear_has_unreglistener() {
  _has_bits_[0] &= ~0x00000004u;
}
void Request::clear_unreglistener() {
  if (unreglistener_ != NULL) unreglistener_->::SensorService::UnregisterListener::Clear();
  clear_has_unreglistener();
}
const ::SensorService::UnregisterListener& Request::unreglistener() const {
  // @@protoc_insertion_point(field_get:SensorService.Request.unRegListener)
  return unreglistener_ != NULL ? *unreglistener_ : *default_instance_->unreglistener_;
}
::SensorService::UnregisterListener* Request::mutable_unreglistener() {
  set_has_unreglistener();
  if (unreglistener_ == NULL) {
    unreglistener_ = new ::SensorService::UnregisterListener;
  }
  // @@protoc_insertion_point(field_mutable:SensorService.Request.unRegListener)
  return unreglistener_;
}
::SensorService::UnregisterListener* Request::release_unreglistener() {
  clear_has_unreglistener();
  ::SensorService::UnregisterListener* temp = unreglistener_;
  unreglistener_ = NULL;
  return temp;
}
void Request::set_allocated_unreglistener(::SensorService::UnregisterListener* unreglistener) {
  delete unreglistener_;
  unreglistener_ = unreglistener;
  if (unreglistener) {
    set_has_unreglistener();
  } else {
    clear_has_unreglistener();
  }
  // @@protoc_insertion_point(field_set_allocated:SensorService.Request.unRegListener)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Response_ResponseType_descriptor_;
}
bool Response_ResponseType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Response_ResponseType Response::SENSOR_LIST;
const Response_ResponseType Response::SENSOR_DATA;
const Response_ResponseType Response::SENSOR_ACCURACY;
const Response_ResponseType Response::ResponseType_MIN;
const Response_ResponseType Response::ResponseType_MAX;
const int Response::ResponseType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Response::kRspTypeFieldNumber;
const int Response::kSensorsFieldNumber;
const int Response::kSensorDataFieldNumber;
const int Response::kSensorAccuracyFieldNumber;
#endif  // !_MSC_VER

Response::Response()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorService.Response)
}

void Response::InitAsDefaultInstance() {
  sensordata_ = const_cast< ::SensorService::SensorDataEvent*>(&::SensorService::SensorDataEvent::default_instance());
  sensoraccuracy_ = const_cast< ::SensorService::SensorAccuracyEvent*>(&::SensorService::SensorAccuracyEvent::default_instance());
}

Response::Response(const Response& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SensorService.Response)
}

void Response::SharedCtor() {
  _cached_size_ = 0;
  rsptype_ = 0;
  sensordata_ = NULL;
  sensoraccuracy_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Response::~Response() {
  // @@protoc_insertion_point(destructor:SensorService.Response)
  SharedDtor();
}

void Response::SharedDtor() {
  if (this != default_instance_) {
    delete sensordata_;
    delete sensoraccuracy_;
  }
}

void Response::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Response::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Response_descriptor_;
}

const Response& Response::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SensorService_2eproto();
  return *default_instance_;
}

Response* Response::default_instance_ = NULL;

Response* Response::New(::google::protobuf::Arena* arena) const {
  Response* n = new Response;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Response::Clear() {
  if (_has_bits_[0 / 32] & 13u) {
    rsptype_ = 0;
    if (has_sensordata()) {
      if (sensordata_ != NULL) sensordata_->::SensorService::SensorDataEvent::Clear();
    }
    if (has_sensoraccuracy()) {
      if (sensoraccuracy_ != NULL) sensoraccuracy_->::SensorService::SensorAccuracyEvent::Clear();
    }
  }
  sensors_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Response::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorService.Response)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .SensorService.Response.ResponseType rspType = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SensorService::Response_ResponseType_IsValid(value)) {
            set_rsptype(static_cast< ::SensorService::Response_ResponseType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sensors;
        break;
      }

      // repeated .SensorService.Sensor sensors = 2;
      case 2: {
        if (tag == 18) {
         parse_sensors:
          DO_(input->IncrementRecursionDepth());
         parse_loop_sensors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_sensors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_sensors;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(26)) goto parse_sensorData;
        break;
      }

      // optional .SensorService.SensorDataEvent sensorData = 3;
      case 3: {
        if (tag == 26) {
         parse_sensorData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sensordata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_sensorAccuracy;
        break;
      }

      // optional .SensorService.SensorAccuracyEvent sensorAccuracy = 4;
      case 4: {
        if (tag == 34) {
         parse_sensorAccuracy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sensoraccuracy()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorService.Response)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorService.Response)
  return false;
#undef DO_
}

void Response::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorService.Response)
  // required .SensorService.Response.ResponseType rspType = 1;
  if (has_rsptype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->rsptype(), output);
  }

  // repeated .SensorService.Sensor sensors = 2;
  for (unsigned int i = 0, n = this->sensors_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->sensors(i), output);
  }

  // optional .SensorService.SensorDataEvent sensorData = 3;
  if (has_sensordata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->sensordata_, output);
  }

  // optional .SensorService.SensorAccuracyEvent sensorAccuracy = 4;
  if (has_sensoraccuracy()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->sensoraccuracy_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorService.Response)
}

::google::protobuf::uint8* Response::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorService.Response)
  // required .SensorService.Response.ResponseType rspType = 1;
  if (has_rsptype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->rsptype(), target);
  }

  // repeated .SensorService.Sensor sensors = 2;
  for (unsigned int i = 0, n = this->sensors_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->sensors(i), target);
  }

  // optional .SensorService.SensorDataEvent sensorData = 3;
  if (has_sensordata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->sensordata_, target);
  }

  // optional .SensorService.SensorAccuracyEvent sensorAccuracy = 4;
  if (has_sensoraccuracy()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->sensoraccuracy_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorService.Response)
  return target;
}

int Response::ByteSize() const {
  int total_size = 0;

  // required .SensorService.Response.ResponseType rspType = 1;
  if (has_rsptype()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->rsptype());
  }
  if (_has_bits_[2 / 32] & 12u) {
    // optional .SensorService.SensorDataEvent sensorData = 3;
    if (has_sensordata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->sensordata_);
    }

    // optional .SensorService.SensorAccuracyEvent sensorAccuracy = 4;
    if (has_sensoraccuracy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->sensoraccuracy_);
    }

  }
  // repeated .SensorService.Sensor sensors = 2;
  total_size += 1 * this->sensors_size();
  for (int i = 0; i < this->sensors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sensors(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Response::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Response* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Response>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Response::MergeFrom(const Response& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  sensors_.MergeFrom(from.sensors_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rsptype()) {
      set_rsptype(from.rsptype());
    }
    if (from.has_sensordata()) {
      mutable_sensordata()->::SensorService::SensorDataEvent::MergeFrom(from.sensordata());
    }
    if (from.has_sensoraccuracy()) {
      mutable_sensoraccuracy()->::SensorService::SensorAccuracyEvent::MergeFrom(from.sensoraccuracy());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Response::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Response::CopyFrom(const Response& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->sensors())) return false;
  if (has_sensordata()) {
    if (!this->sensordata_->IsInitialized()) return false;
  }
  if (has_sensoraccuracy()) {
    if (!this->sensoraccuracy_->IsInitialized()) return false;
  }
  return true;
}

void Response::Swap(Response* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Response::InternalSwap(Response* other) {
  std::swap(rsptype_, other->rsptype_);
  sensors_.UnsafeArenaSwap(&other->sensors_);
  std::swap(sensordata_, other->sensordata_);
  std::swap(sensoraccuracy_, other->sensoraccuracy_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Response::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Response_descriptor_;
  metadata.reflection = Response_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Response

// required .SensorService.Response.ResponseType rspType = 1;
bool Response::has_rsptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Response::set_has_rsptype() {
  _has_bits_[0] |= 0x00000001u;
}
void Response::clear_has_rsptype() {
  _has_bits_[0] &= ~0x00000001u;
}
void Response::clear_rsptype() {
  rsptype_ = 0;
  clear_has_rsptype();
}
 ::SensorService::Response_ResponseType Response::rsptype() const {
  // @@protoc_insertion_point(field_get:SensorService.Response.rspType)
  return static_cast< ::SensorService::Response_ResponseType >(rsptype_);
}
 void Response::set_rsptype(::SensorService::Response_ResponseType value) {
  assert(::SensorService::Response_ResponseType_IsValid(value));
  set_has_rsptype();
  rsptype_ = value;
  // @@protoc_insertion_point(field_set:SensorService.Response.rspType)
}

// repeated .SensorService.Sensor sensors = 2;
int Response::sensors_size() const {
  return sensors_.size();
}
void Response::clear_sensors() {
  sensors_.Clear();
}
const ::SensorService::Sensor& Response::sensors(int index) const {
  // @@protoc_insertion_point(field_get:SensorService.Response.sensors)
  return sensors_.Get(index);
}
::SensorService::Sensor* Response::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:SensorService.Response.sensors)
  return sensors_.Mutable(index);
}
::SensorService::Sensor* Response::add_sensors() {
  // @@protoc_insertion_point(field_add:SensorService.Response.sensors)
  return sensors_.Add();
}
::google::protobuf::RepeatedPtrField< ::SensorService::Sensor >*
Response::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:SensorService.Response.sensors)
  return &sensors_;
}
const ::google::protobuf::RepeatedPtrField< ::SensorService::Sensor >&
Response::sensors() const {
  // @@protoc_insertion_point(field_list:SensorService.Response.sensors)
  return sensors_;
}

// optional .SensorService.SensorDataEvent sensorData = 3;
bool Response::has_sensordata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Response::set_has_sensordata() {
  _has_bits_[0] |= 0x00000004u;
}
void Response::clear_has_sensordata() {
  _has_bits_[0] &= ~0x00000004u;
}
void Response::clear_sensordata() {
  if (sensordata_ != NULL) sensordata_->::SensorService::SensorDataEvent::Clear();
  clear_has_sensordata();
}
const ::SensorService::SensorDataEvent& Response::sensordata() const {
  // @@protoc_insertion_point(field_get:SensorService.Response.sensorData)
  return sensordata_ != NULL ? *sensordata_ : *default_instance_->sensordata_;
}
::SensorService::SensorDataEvent* Response::mutable_sensordata() {
  set_has_sensordata();
  if (sensordata_ == NULL) {
    sensordata_ = new ::SensorService::SensorDataEvent;
  }
  // @@protoc_insertion_point(field_mutable:SensorService.Response.sensorData)
  return sensordata_;
}
::SensorService::SensorDataEvent* Response::release_sensordata() {
  clear_has_sensordata();
  ::SensorService::SensorDataEvent* temp = sensordata_;
  sensordata_ = NULL;
  return temp;
}
void Response::set_allocated_sensordata(::SensorService::SensorDataEvent* sensordata) {
  delete sensordata_;
  sensordata_ = sensordata;
  if (sensordata) {
    set_has_sensordata();
  } else {
    clear_has_sensordata();
  }
  // @@protoc_insertion_point(field_set_allocated:SensorService.Response.sensorData)
}

// optional .SensorService.SensorAccuracyEvent sensorAccuracy = 4;
bool Response::has_sensoraccuracy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Response::set_has_sensoraccuracy() {
  _has_bits_[0] |= 0x00000008u;
}
void Response::clear_has_sensoraccuracy() {
  _has_bits_[0] &= ~0x00000008u;
}
void Response::clear_sensoraccuracy() {
  if (sensoraccuracy_ != NULL) sensoraccuracy_->::SensorService::SensorAccuracyEvent::Clear();
  clear_has_sensoraccuracy();
}
const ::SensorService::SensorAccuracyEvent& Response::sensoraccuracy() const {
  // @@protoc_insertion_point(field_get:SensorService.Response.sensorAccuracy)
  return sensoraccuracy_ != NULL ? *sensoraccuracy_ : *default_instance_->sensoraccuracy_;
}
::SensorService::SensorAccuracyEvent* Response::mutable_sensoraccuracy() {
  set_has_sensoraccuracy();
  if (sensoraccuracy_ == NULL) {
    sensoraccuracy_ = new ::SensorService::SensorAccuracyEvent;
  }
  // @@protoc_insertion_point(field_mutable:SensorService.Response.sensorAccuracy)
  return sensoraccuracy_;
}
::SensorService::SensorAccuracyEvent* Response::release_sensoraccuracy() {
  clear_has_sensoraccuracy();
  ::SensorService::SensorAccuracyEvent* temp = sensoraccuracy_;
  sensoraccuracy_ = NULL;
  return temp;
}
void Response::set_allocated_sensoraccuracy(::SensorService::SensorAccuracyEvent* sensoraccuracy) {
  delete sensoraccuracy_;
  sensoraccuracy_ = sensoraccuracy;
  if (sensoraccuracy) {
    set_has_sensoraccuracy();
  } else {
    clear_has_sensoraccuracy();
  }
  // @@protoc_insertion_point(field_set_allocated:SensorService.Response.sensorAccuracy)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace SensorService

// @@protoc_insertion_point(global_scope)
